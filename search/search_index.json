{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SQA - Simple Qualitative Analysis","text":"<p> A Powerful Ruby Library for Stock Market Technical Analysis </p>"},{"location":"#welcome-to-sqa","title":"Welcome to SQA","text":"<p>SQA (Simple Qualitative Analysis) is an educational Ruby library designed for stock market technical analysis and trading strategy development. Built with high-performance data structures and seamlessly integrated with TA-Lib, SQA provides a comprehensive toolkit for analyzing historical stock data, implementing trading strategies, and backtesting your ideas.</p> <p>Educational Purpose Only</p> <p>SQA is designed for educational purposes only. It should not be used for actual trading without extensive testing and professional financial advice. Trading stocks involves substantial risk of loss.</p>"},{"location":"#why-sqa","title":"Why SQA?","text":""},{"location":"#high-performance","title":"High Performance","text":"<ul> <li>Polars DataFrames: Rust-backed data structures providing 30x faster operations than pure Ruby</li> <li>TA-Lib Integration: Access to 150+ battle-tested technical indicators via the <code>sqa-tai</code> gem</li> <li>Efficient Algorithms: Optimized for large historical datasets</li> </ul>"},{"location":"#comprehensive-feature-set","title":"Comprehensive Feature Set","text":"<ul> <li>13+ Trading Strategies: From simple moving averages to advanced machine learning-based strategies</li> <li>Portfolio Management: Track positions, calculate P&amp;L, manage commissions</li> <li>Backtesting Framework: Simulate strategies with comprehensive performance metrics</li> <li>Real-Time Streaming: Process live price data with callback support</li> <li>Strategy Generation: Reverse-engineer profitable trades to discover patterns</li> <li>Genetic Programming: Evolve optimal strategy parameters</li> </ul>"},{"location":"#educational-focus","title":"Educational Focus","text":"<ul> <li>Clear Documentation: Extensive guides and examples</li> <li>Transparent Algorithms: Understand how each indicator and strategy works</li> <li>Modular Design: Learn by building custom strategies</li> <li>Risk Disclaimers: Honest about limitations and risks</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>require 'sqa'\n\n# Initialize SQA\nSQA.init\n\n# Load stock data\nstock = SQA::Stock.new(ticker: 'AAPL')\n\n# Get price data\nprices = stock.df[\"adj_close_price\"].to_a\n\n# Calculate RSI indicator\nrsi = SQAI.rsi(prices, period: 14)\n\n# Execute RSI trading strategy\nrequire 'ostruct'\nvector = OpenStruct.new(rsi: { trend: rsi.last &lt; 30 ? :over_sold : :over_bought })\nsignal = SQA::Strategy::RSI.trade(vector)  # =&gt; :buy, :sell, or :hold\n\n# Backtest the strategy\nbacktest = SQA::Backtest.new(\n  stock: stock,\n  strategy: SQA::Strategy::RSI,\n  initial_cash: 10_000\n)\nresults = backtest.run\n\nputs \"Total Return: #{results.total_return}%\"\nputs \"Sharpe Ratio: #{results.sharpe_ratio}\"\nputs \"Max Drawdown: #{results.max_drawdown}%\"\n</code></pre>"},{"location":"#core-features","title":"Core Features","text":""},{"location":"#data-management","title":"Data Management","text":"<ul> <li>Multiple Data Sources: Alpha Vantage, Yahoo Finance, CSV imports</li> <li>Polars DataFrames: High-performance time series data manipulation</li> <li>Automatic Updates: Keep historical data current</li> </ul>"},{"location":"#technical-analysis","title":"Technical Analysis","text":"<ul> <li>150+ Indicators: SMA, EMA, RSI, MACD, Bollinger Bands, Stochastic, ADX, ATR, and more</li> <li>Custom Calculations: Build your own indicators</li> <li>Trend Detection: Identify market conditions automatically</li> </ul>"},{"location":"#trading-strategies","title":"Trading Strategies","text":"<ul> <li>Built-in Strategies: RSI, MACD, Bollinger Bands, Moving Average crossovers, Volume Breakout</li> <li>Strategy Framework: Plugin architecture for custom strategies</li> <li>Consensus Approach: Combine multiple strategies</li> <li>Rule-Based (KBS): RETE-based forward-chaining inference engine</li> </ul>"},{"location":"#advanced-analytics","title":"Advanced Analytics","text":"<ul> <li>Portfolio Tracking: Monitor positions, P&amp;L, commissions</li> <li>Backtesting: Historical simulation with performance metrics</li> <li>Strategy Generator: Mine patterns from profitable trades</li> <li>Genetic Programming: Evolutionary parameter optimization</li> <li>FPOP Analysis: Future Period of Performance calculations</li> <li>Real-Time Streaming: Process live data with event callbacks</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[Stock Data] --&gt; B[SQA::DataFrame]\n    B --&gt; C[Technical Indicators]\n    C --&gt; D[Trading Strategies]\n    D --&gt; E{Strategy Type}\n    E --&gt;|Simple| F[SMA/EMA/RSI]\n    E --&gt;|Advanced| G[MACD/Bollinger]\n    E --&gt;|Rule-Based| H[KBS Strategy]\n    D --&gt; I[Portfolio Management]\n    I --&gt; J[Backtesting]\n    J --&gt; K[Performance Metrics]\n\n    L[Real-Time Data] --&gt; M[SQA::Stream]\n    M --&gt; D\n\n    N[Pattern Discovery] --&gt; O[StrategyGenerator]\n    O --&gt; P[Generated Strategies]\n    P --&gt; D</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to dive in? Check out our guides:</p> <ul> <li>Installation Guide - Get SQA up and running</li> <li>Quick Start - Your first analysis in minutes</li> </ul>"},{"location":"#key-resources","title":"Key Resources","text":""},{"location":"#for-beginners","title":"For Beginners","text":"<ul> <li>Core Concepts - Understand the fundamentals</li> <li>Technical Indicators - Learn about indicators</li> <li>Trading Strategies - Explore built-in strategies</li> </ul>"},{"location":"#for-advanced-users","title":"For Advanced Users","text":"<ul> <li>Portfolio Management - Track your trades</li> <li>Backtesting - Test strategies historically</li> <li>Strategy Generator - Discover patterns</li> <li>Genetic Programming - Optimize parameters</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>API Documentation - Complete API reference</li> <li>Data Sources - Working with data</li> <li>Terms of Use - Important legal information</li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub: github.com/madbomber/sqa</li> <li>RubyGems: rubygems.org/gems/sqa</li> <li>Issues: Report bugs or request features on GitHub Issues</li> </ul>"},{"location":"#license","title":"License","text":"<p>SQA is released under the MIT License. See the LICENSE file for details.</p> <p> Remember: The House Always Wins Trade responsibly. Never risk more than you can afford to lose. </p>"},{"location":"ai_and_ml/","title":"Ai and ml","text":""},{"location":"ai_and_ml/#ai-and-ml-in-trading-advancing-decision-making","title":"AI and ML in Trading -- Advancing Decision-Making","text":"<p>The realm of financial trading has experienced a wonderful transformation with the benefit of algorithmic trading. This innovative approach, which utilizes automated and pre-programmed instructions, has elevated the trading game to new heights. It excels in executing trades with incredible speed and accuracy, focusing on various factors such as price, timing, and volume. The key to its enhanced performance lies in the integration of machine learning (ML) and artificial intelligence (AI). These technologies are useful for the prediction power which was impossible permitting traders to understand the difficulties of the market with enhancement.  </p> <p>Machine learning in Algo trading, in particular, has been a game-changer. It enables systems to learn from historical data, adapt to changing market dynamics, and make informed predictions about future market behaviors. This evolution has not only streamlined trading operations but also opened up new avenues for strategic and dynamic trading decisions, revolutionizing the way financial markets operate.</p>"},{"location":"ai_and_ml/#applications-in-algorithmic-trading","title":"Applications in Algorithmic Trading","text":"<p>Algorithmic trading has revolutionized the financial world by its rapidness and accuracy in the trading procedure. With the integration of artificial intelligence, these systems have become more easier. Here are several key applications of AI in algo trading:</p>"},{"location":"ai_and_ml/#predictive-analytics-for-market-trends","title":"Predictive Analytics for Market Trends","text":"<p>AI algorithms analyze vast datasets, including historical price data, news, and economic reports, to predict market trends. Techniques like sentiment analysis are used to gauge market mood from social media and news sources, offering insights into potential market movements. Time-series forecasting models, driven by AI, help in predicting future price movements based on past trends.</p> <p>Risk Management and Mitigation  </p> <p>AI in algo trading enhances the ability to identify and assess risks. By analyzing market conditions and historical data, these systems can predict volatility and potential downturns. Advanced models help in diversifying portfolios to minimize risk and optimize returns. Real-time monitoring tools powered by AI detect anomalies and potential market manipulations, safeguarding investments.</p>"},{"location":"ai_and_ml/#portfolio-optimization","title":"Portfolio Optimization","text":"<p>AI systems analyze historical performance data and market conditions to construct optimized portfolios that align with specific investment goals and risk tolerances. These algorithms continuously adjust portfolios in response to market changes, ensuring optimal asset allocation.</p>"},{"location":"ai_and_ml/#algorithmic-market-making","title":"Algorithmic Market Making","text":"<p>AI-driven algorithms act as market makers, providing liquidity to the market by continuously buying and selling securities. These algorithms adjust bid-ask spreads based on market conditions, balancing profit-making with the need to maintain market stability.</p>"},{"location":"ai_and_ml/#sentiment-analysis-and-behavioral-finance","title":"Sentiment Analysis and Behavioral Finance","text":"<p>AI tools perform sentiment analysis on news articles, social media, and financial reports to understand market sentiment. Behavioral biases in trading decisions are identified and countered using AI, leading to more rational decision-making.</p>"},{"location":"ai_and_ml/#fraud-detection-and-compliance","title":"Fraud Detection and Compliance","text":"<p>AI algorithms in algo trading detect patterns indicative of fraudulent activities, enhancing the security of trading platforms. Compliance monitoring is automated, ensuring adherence to regulatory standards and reducing the risk of legal issues.</p>"},{"location":"ai_and_ml/#customized-trading-solutions","title":"Customized Trading Solutions","text":"<p>AI app development companies enable the creation of personalized trading strategies based on individual investor profiles and preferences. It offers tailored advice and recommendations, improving client engagement and satisfaction.</p>"},{"location":"ai_and_ml/#real-time-data-processing-and-decision-making","title":"Real-time Data Processing and Decision Making","text":"<p>AI systems process real-time market data to make immediate trading decisions, capitalizing on short-lived trading opportunities. They can adjust strategies instantaneously in response to live market data, maintaining relevance and effectiveness.</p>"},{"location":"ai_and_ml/#predictive-maintenance-in-trading-infrastructure","title":"Predictive Maintenance in Trading Infrastructure","text":"<p>AI is used to predict and prevent system failures in trading infrastructure, ensuring uninterrupted operations. Predictive maintenance minimizes downtime and maintains the reliability of trading systems.</p>"},{"location":"ai_and_ml/#advancing-decision-making-with-ai-and-ml-in-algorithmic-trading","title":"Advancing Decision Making with AI and ML in Algorithmic Trading","text":""},{"location":"ai_and_ml/#incorporation-of-ai-in-software-development-for-trading-systems","title":"Incorporation of AI in Software Development for Trading Systems","text":"<p>The evolution of algorithmic trading is significantly influenced by advancements in AI-driven software development. Software development companies are now focusing on integrating AI and ML into trading platforms, enhancing their capability to process and analyze massive data sets rapidly. This integration allows for the creation of more sophisticated and accurate trading models. By adopting AI, these companies can develop software that not only processes historical and real-time market data efficiently but also predicts future market trends, contributing to more informed trading decisions.</p>"},{"location":"ai_and_ml/#mobile-app-development-for-on-the-go-trading","title":"Mobile App Development for On-the-Go Trading","text":"<p>The demand for mobile app development services in the financial sector has reached the heights of the sky mainly for algorithmic trading.\u00a0 These mobile apps, empowered by AI and ML algorithms, provide traders with the flexibility to monitor and execute trades anytime and anywhere. The incorporation of AI in these apps offers real-time analytics, market insights, and personalized notifications, ensuring that traders stay ahead in the fast-paced trading environment. This advancement in mobile technology means that traders can now make data-driven decisions on the go, with AI providing constant insights and updates.</p>"},{"location":"ai_and_ml/#enhancing-trading-platforms-with-dedicated-ai-expertise","title":"Enhancing Trading Platforms with Dedicated AI Expertise.","text":"<p>To harness the full potential of AI and ML in algorithmic trading, it's essential to hire dedicated developers who specialize in AI. Their expertise helps in refining the AI models used in algo trading platforms, ensuring that they are not only efficient but also accurate and reliable. Dedicated developers bring a depth of knowledge in AI and ML, driving innovations that keep trading platforms at the forefront of the financial industry.</p>"},{"location":"ai_and_ml/#collaboration-with-artificial-intelligence-development-companies","title":"Collaboration with Artificial Intelligence Development Companies","text":"<p>The partnership between algo trading firms and artificial intelligence development companies is pivotal in advancing trading strategies. These collaborations bring together financial expertise and cutting-edge AI technology. AI development companies provide the technological backbone, developing complex algorithms capable of predictive analytics, risk assessment, and decision automation. It leads to more powerful trading platforms, which can process a huge amount of data and make autonomous, great decisions that would be hard to make for human traders.</p>"},{"location":"ai_and_ml/#leveraging-algo-trading-platforms-for-enhanced-decision-making","title":"Leveraging Algo Trading Platforms for Enhanced Decision-Making","text":"<p>Algo trading platforms have become more advanced with the integration of AI and ML, offering traders a myriad of tools for enhanced decision-making. These platforms utilize AI to analyze market conditions, predict price movements, and identify trading opportunities. They can automatically adjust trading strategies in real-time, responding to market changes instantaneously. This level of automation and precision in decision-making permits traders to focus on market opportunities more efficiently, minimizing risks, and enhancing overall trading performance.</p>"},{"location":"ai_and_ml/#future-trends-and-developments-in-ai-and-ml-for-trading","title":"Future Trends and Developments in AI and ML for Trading","text":"<p>Looking forward, the continued integration of AI and ML in algorithmic trading promises even more sophisticated and efficient trading systems. Growth in areas like deep learning, and natural language processing will again improve the abilities of algo trading platforms. As AI and ML technologies evolve, they will offer more nuanced and complex analysis, leading to even more refined decision-making processes in trading. The ongoing collaboration with dedicated AI developers, and financial experts will be crucial in driving these advancements and shaping the future of algorithmic trading in the financial markets.</p> <p>The advancement of decision-making in algorithmic trading through AI and ML is a multifaceted process that involves the collaboration of software development companies, the creation of mobile trading apps, the hiring of dedicated developers, partnerships with AI development firms, and the continuous improvement of algo trading platforms.</p>"},{"location":"ai_and_ml/#conclusion","title":"Conclusion:","text":"<p>The blend of artificial intelligence and machine learning in algo trading is nothing but a kind of transformation in the financial world. This blend has not just automated the existing processes but has infused them with an unprecedented level of accuracy and sophistication. These advancements empower traders to make decisions swiftly and more accurately, effectively reshaping the entire trading landscape. As we look ahead, the continuous evolution of these technologies heralds a future rich with innovative strategies and heightened efficiency in trading. In this new era, driven by AI and ML, the essence of successful trading will increasingly hinge on the ability to harness data-driven insights and automated decision-making.</p>"},{"location":"data_frame/","title":"DataFrame Documentation","text":""},{"location":"data_frame/#overview","title":"Overview","text":"<p>The <code>SQA::DataFrame</code> class is a high-performance wrapper around the Polars DataFrame library, specifically designed for time series financial data manipulation. Polars is a Rust-backed library that provides blazingly fast operations on columnar data.</p>"},{"location":"data_frame/#architecture","title":"Architecture","text":"<p>The DataFrame system consists of two main components:</p>"},{"location":"data_frame/#1-sqadataframe","title":"1. SQA::DataFrame","text":"<p>The main DataFrame class that wraps Polars::DataFrame with SQA-specific convenience methods.</p> <p>Location: <code>lib/sqa/data_frame.rb</code></p> <p>Key Features: - Wraps Polars::DataFrame for high-performance operations - Column-based vectorized operations (avoid row iterations) - CSV and JSON import/export - Automatic column renaming and transformations - FPL (Future Period Loss/Profit) analysis convenience methods - Method delegation to underlying Polars DataFrame</p>"},{"location":"data_frame/#2-sqadataframedata","title":"2. SQA::DataFrame::Data","text":"<p>A metadata storage class for stock information, separate from the price/volume data.</p> <p>Location: <code>lib/sqa/data_frame/data.rb</code></p> <p>Attributes: - <code>ticker</code> - Stock symbol (e.g., 'AAPL', 'MSFT') - <code>name</code> - Company name - <code>exchange</code> - Exchange symbol (NASDAQ, NYSE, etc.) - <code>source</code> - Data source (<code>:alpha_vantage</code>, <code>:yahoo_finance</code>) - <code>indicators</code> - Technical indicators configuration hash - <code>overview</code> - Company overview data from Alpha Vantage</p> <p>Key Features: - Dual initialization: from hash (JSON) or keyword arguments - JSON serialization with <code>to_json</code> - Used by <code>SQA::Stock</code> to persist metadata in <code>~/sqa_data/ticker.json</code> - All attributes are read/write accessible</p>"},{"location":"data_frame/#creating-dataframes","title":"Creating DataFrames","text":""},{"location":"data_frame/#from-data-sources","title":"From Data Sources","text":"<pre><code># Using Alpha Vantage\nstock = SQA::Stock.new(ticker: 'AAPL')\ndf = stock.df  # SQA::DataFrame instance\n\n# Using Yahoo Finance\nstock = SQA::Stock.new(ticker: 'MSFT', source: :yahoo_finance)\ndf = stock.df\n</code></pre>"},{"location":"data_frame/#from-csv-file","title":"From CSV File","text":"<pre><code># Load CSV file (Polars-compatible)\ndf = SQA::DataFrame.from_csv_file('path/to/stock_data.csv')\n\n# The underlying Polars DataFrame is accessible via .data\npolars_df = df.data\n</code></pre>"},{"location":"data_frame/#from-json-file","title":"From JSON File","text":"<pre><code># Load JSON array of hashes\ndf = SQA::DataFrame.from_json_file('path/to/stock_data.json')\n</code></pre>"},{"location":"data_frame/#from-array-of-hashes","title":"From Array of Hashes","text":"<pre><code>data = [\n  { date: '2024-01-01', close: 150.0, volume: 1_000_000 },\n  { date: '2024-01-02', close: 152.0, volume: 1_200_000 }\n]\n\ndf = SQA::DataFrame.from_aofh(data)\n</code></pre>"},{"location":"data_frame/#working-with-dataframes","title":"Working with DataFrames","text":""},{"location":"data_frame/#column-access","title":"Column Access","text":"<pre><code># Get column names\ndf.columns\n# =&gt; [\"timestamp\", \"open\", \"high\", \"low\", \"close\", \"adj_close_price\", \"volume\"]\n\n# Access a column (returns Polars::Series)\nclose_prices = df[\"close\"]\n\n# Convert to Ruby array\nprices_array = df[\"adj_close_price\"].to_a\n</code></pre>"},{"location":"data_frame/#basic-operations","title":"Basic Operations","text":"<pre><code># Get dimensions\ndf.size      # Number of rows (also: df.nrows, df.length)\ndf.ncols     # Number of columns\n\n# Get first/last rows\ndf.head(10)  # First 10 rows\ndf.tail(10)  # Last 10 rows\n\n# Column statistics (via Polars)\ndf.data[\"close\"].mean\ndf.data[\"volume\"].sum\ndf.data[\"close\"].min\ndf.data[\"close\"].max\n</code></pre>"},{"location":"data_frame/#data-transformation","title":"Data Transformation","text":"<pre><code># Rename columns\nmapping = { 'Close' =&gt; :close, 'Volume' =&gt; :volume }\ndf.rename_columns!(mapping)\n\n# Apply transformers\ntransformers = {\n  date: -&gt;(val) { Date.parse(val) },\n  volume: -&gt;(val) { val.to_i }\n}\ndf.apply_transformers!(transformers)\n</code></pre>"},{"location":"data_frame/#appending-dataframes","title":"Appending DataFrames","text":"<pre><code># Combine two DataFrames\ndf1.append!(df2)  # Modifies df1 in place\ndf1.concat!(df2)  # Alias for append!\n</code></pre>"},{"location":"data_frame/#export","title":"Export","text":"<pre><code># To CSV\ndf.to_csv('output.csv')\ndf.write_csv('output.csv')  # Alias\n\n# To Hash\nhash = df.to_h\n# =&gt; { close: [150.0, 152.0, ...], volume: [1_000_000, 1_200_000, ...] }\n</code></pre>"},{"location":"data_frame/#fpl-analysis-methods","title":"FPL Analysis Methods","text":"<p>The DataFrame includes convenience methods for Future Period Loss/Profit analysis:</p>"},{"location":"data_frame/#basic-fpl-calculation","title":"Basic FPL Calculation","text":"<pre><code># Calculate min/max future deltas for each point\nfpl_data = df.fpl(column: \"adj_close_price\", fpop: 10)\n# =&gt; [[min_delta, max_delta], [min_delta, max_delta], ...]\n</code></pre>"},{"location":"data_frame/#comprehensive-fpl-analysis","title":"Comprehensive FPL Analysis","text":"<pre><code># Get detailed analysis with risk metrics\nanalysis = df.fpl_analysis(column: \"adj_close_price\", fpop: 10)\n# =&gt; [\n#   {\n#     min_delta: -2.5,\n#     max_delta: 5.3,\n#     magnitude: 3.9,\n#     risk: 7.8,\n#     direction: :UP\n#   },\n#   ...\n# ]\n</code></pre> <p>See FPL Analysis Documentation for more details.</p>"},{"location":"data_frame/#working-with-stock-metadata","title":"Working with Stock Metadata","text":""},{"location":"data_frame/#creating-metadata","title":"Creating Metadata","text":"<pre><code># From keyword arguments\ndata = SQA::DataFrame::Data.new(\n  ticker: 'AAPL',\n  source: :alpha_vantage,\n  indicators: { rsi: 14, sma: [20, 50] }\n)\n\n# From hash (JSON deserialization)\njson_data = JSON.parse(File.read('aapl.json'))\ndata = SQA::DataFrame::Data.new(json_data)\n</code></pre>"},{"location":"data_frame/#accessing-and-modifying-metadata","title":"Accessing and Modifying Metadata","text":"<pre><code># Read attributes\ndata.ticker        # =&gt; 'AAPL'\ndata.source        # =&gt; :alpha_vantage\ndata.indicators    # =&gt; { rsi: 14, sma: [20, 50] }\n\n# Write attributes\ndata.name = 'Apple Inc.'\ndata.exchange = 'NASDAQ'\ndata.overview = {\n  'company' =&gt; 'Apple Inc.',\n  'sector' =&gt; 'Technology',\n  'market_cap' =&gt; 2_800_000_000_000\n}\n</code></pre>"},{"location":"data_frame/#persistence","title":"Persistence","text":"<pre><code># Serialize to JSON\njson_string = data.to_json\n\n# Save to file (typically done by SQA::Stock)\nFile.write('aapl.json', data.to_json)\n\n# Load from file\njson_data = JSON.parse(File.read('aapl.json'))\ndata = SQA::DataFrame::Data.new(json_data)\n</code></pre>"},{"location":"data_frame/#performance-tips","title":"Performance Tips","text":"<ol> <li> <p>Use Column Operations: Always prefer Polars column operations over Ruby loops    <pre><code># GOOD: Vectorized operation\ndf.data[\"close\"].mean\n\n# BAD: Ruby loop\ndf[\"close\"].to_a.sum / df.size.to_f\n</code></pre></p> </li> <li> <p>Access Underlying Polars: Use <code>df.data</code> for direct Polars operations    <pre><code># Direct Polars access\nfiltered = df.data.filter(df.data[\"volume\"] &gt; 1_000_000)\n</code></pre></p> </li> <li> <p>Avoid Unnecessary Array Conversions: Only convert to arrays when needed    <pre><code># Only convert when passing to external functions\nprices = df[\"adj_close_price\"].to_a\nrsi = SQAI.rsi(prices, period: 14)\n</code></pre></p> </li> <li> <p>Batch Operations: Combine operations when possible    <pre><code># Instead of multiple separate operations\ndf.apply_transformers!(transformers)\ndf.rename_columns!(mapping)\n</code></pre></p> </li> </ol>"},{"location":"data_frame/#data-sources","title":"Data Sources","text":""},{"location":"data_frame/#alpha-vantage","title":"Alpha Vantage","text":"<p>Location: <code>lib/sqa/data_frame/alpha_vantage.rb</code></p> <pre><code>SQA::DataFrame::AlphaVantage.recent('AAPL', full: true)\n</code></pre> <p>Requirements: - Environment variable: <code>AV_API_KEY</code> or <code>ALPHAVANTAGE_API_KEY</code> - Rate limiting: 5 calls/minute (free tier)</p>"},{"location":"data_frame/#yahoo-finance","title":"Yahoo Finance","text":"<p>Location: <code>lib/sqa/data_frame/yahoo_finance.rb</code></p> <pre><code>SQA::DataFrame::YahooFinance.recent('AAPL', full: true)\n</code></pre> <p>Features: - No API key required - Web scraping based (less reliable) - Good for testing and fallback</p>"},{"location":"data_frame/#adding-new-data-sources","title":"Adding New Data Sources","text":"<p>To add a new data source adapter:</p> <ol> <li>Create <code>lib/sqa/data_frame/my_source.rb</code></li> <li>Define class <code>SQA::DataFrame::MySource</code></li> <li>Implement <code>self.recent(ticker, **options)</code> method</li> <li>Return data in Polars-compatible format</li> <li>Add column mapping if needed</li> </ol> <p>Example:</p> <pre><code>class SQA::DataFrame::MySource\n  TRANSFORMERS = {\n    timestamp: -&gt;(val) { Date.parse(val) },\n    volume: -&gt;(val) { val.to_i }\n  }\n\n  def self.recent(ticker, **options)\n    # Fetch data from your source\n    raw_data = fetch_from_api(ticker)\n\n    # Convert to Polars-compatible format\n    SQA::DataFrame.new(raw_data, transformers: TRANSFORMERS)\n  end\nend\n</code></pre>"},{"location":"data_frame/#common-gotchas","title":"Common Gotchas","text":"<ol> <li>DataFrame vs Polars:</li> <li><code>df</code> is <code>SQA::DataFrame</code></li> <li> <p><code>df.data</code> is <code>Polars::DataFrame</code></p> </li> <li> <p>Column Names:</p> </li> <li>Column names are strings, not symbols</li> <li> <p>Use <code>df[\"close\"]</code> not <code>df[:close]</code></p> </li> <li> <p>Method Delegation:</p> </li> <li>Unknown methods are delegated to Polars::DataFrame</li> <li> <p>Check Polars docs for advanced operations</p> </li> <li> <p>Indicators Need Arrays:</p> </li> <li>Extract data with <code>.to_a</code> before passing to SQAI/TAI functions</li> <li>Example: <code>prices = df[\"close\"].to_a</code></li> </ol>"},{"location":"data_frame/#related-documentation","title":"Related Documentation","text":"<ul> <li>FPL Analysis - Future Period Loss/Profit utilities</li> <li>Indicators - Technical indicator integration</li> <li>Polars Documentation - Underlying library</li> </ul>"},{"location":"data_frame/#example-complete-workflow","title":"Example: Complete Workflow","text":"<pre><code>require 'sqa'\n\nSQA.init\n\n# Load stock data\nstock = SQA::Stock.new(ticker: 'AAPL')\n\n# Access DataFrame\ndf = stock.df\n\n# Get price array for indicators\nprices = df[\"adj_close_price\"].to_a\n\n# Calculate technical indicators\nsma_20 = SQAI.sma(prices, period: 20)\nrsi_14 = SQAI.rsi(prices, period: 14)\n\n# FPL analysis\nfpl_analysis = df.fpl_analysis(fpop: 10)\nhigh_quality = SQA::FPOP.filter_by_quality(\n  fpl_analysis,\n  min_magnitude: 5.0,\n  max_risk: 25.0\n)\n\n# Access stock metadata\nputs \"Ticker: #{stock.ticker}\"\nputs \"Exchange: #{stock.exchange}\"\nputs \"Source: #{stock.source}\"\n\n# Export data\ndf.to_csv(\"aapl_prices.csv\")\nFile.write(\"aapl_metadata.json\", stock.data.to_json)\n</code></pre>"},{"location":"factors_that_impact_price/","title":"Factor Analysis","text":""},{"location":"factors_that_impact_price/#factors-that-impact-price","title":"Factors that Impact Price","text":"<p>By considering these factors, investors can better understand the potential price movements of stocks and make informed investment decisions.</p> <p>This breakdown approximates how heavily each factor might typically weigh on stock prices across a varied portfolio. However, in specific scenarios, the impact of each factor could be dramatically different. For instance, in times of global financial crisis, economic indicators and market sentiment might dramatically outweigh company-specific performance, or during a technological breakthrough, industry trends could be the dominant factor.</p> <p>Ranked most impactful to least impactful.</p> <ol> <li>Company Performance: 35%</li> <li> <p>The financial health and growth prospects of a company are crucial. Positive earnings reports, strong revenue growth, and effective management often directly translate to increased stock prices.</p> </li> <li> <p>Market Sentiment: 25%</p> </li> <li> <p>This is a broad factor that encompasses the psychological aspects of the market. Positive market sentiment can drive prices up rapidly, sometimes irrespective of underlying fundamentals.</p> </li> <li> <p>Economic Indicators: 15%</p> </li> <li> <p>Broad economic trends greatly influence investor confidence and expectations. Robust economic growth, for example, tends to buoy most stocks, particularly in sectors closely tied to economic cycles.</p> </li> <li> <p>Interest Rates: 10%</p> </li> <li> <p>Changes in interest rates by central banks can shift investor preferences between stocks and bonds, thus having a significant impact on stock prices.</p> </li> <li> <p>Geopolitical Events: 10%</p> </li> <li> <p>These events can create considerable market volatility and can impact specific sectors more intensely (e.g., energy stocks during oil crises).</p> </li> <li> <p>Industry Trends: 5%</p> </li> <li>While these can be highly impactful on specific stocks or sectors, their broader impact on stock prices across the market tends to be more contained compared to the other factors unless the trend sparks a sector-wide shift.</li> </ol>"},{"location":"finviz/","title":"Financial Vizualization (finviz)","text":"<p>The original finviz unofficial gem has been untouched for 3 years.  I just forked it in the hope that I can bring it forward to current versions of its dependencies.</p> <p>https;//finviz.com</p>"},{"location":"finviz/#aapl-weekly","title":"AAPL weekly","text":"<p>The default is daily.</p> <p>https://finviz.com/quote.ashx?t=AAPL&amp;p=w</p>"},{"location":"fx_pro_bit/","title":"FXProBot","text":"<p>FXProBot is a new trading software by Avenix Fzco, a major fintech firm located in Dubai that specializes in automated trading. This advanced robot has been built with the sole aim of improving the experience of both established and novice traders by using sophisticated algorithms and strong risk management approaches. The goal of FXProBot is to change how investors interact with the market; it offers an efficient and effortless platform for forex traders.</p>"},{"location":"fx_pro_bit/#main-features-of-fxprobot","title":"Main Features of FXProBot","text":"<p>Impulse Detection and Analysis \u2013 One of the key attributes of this bot is its well-crafted impulse detection and analysis process. Before initiating any trade, this forex robot scans market impulses, searching for ones that may benefit traders. In instances such as when Doji candles appear or ambiguous market behavior occurs, this feature helps avoid common mistakes.</p> <p>Trend Conformity \u2013 This feature comes into play when market impulses are aligned with broader market trends. Trade entry accuracy is enhanced by FXProBot\u2019s built-in indicators. In this way, it increases the chances for better trading opportunities, since FXProBot trades in line with prevailing market trends.</p> <p>Robust Risk Management \u2013 Successful trading necessitates good risk management, which FXProBot demonstrates excellently. Each trade executed by this forex robot incorporates predefined levels for Stop Loss (SL) and Take Profit (TP). This strong framework used for risk management promotes minimal losses, thus safeguarding profits and investments from instability.</p> <p>Automated Trading \u2013 Trading has become simpler thanks to automated trading offered by FXProBot. This Expert Advisor (EA) uses complex algorithms, ensuring accuracy as it removes emotions and psychological stress from trading decisions. This means that traders can focus on their strategies while FXProBot takes care of execution.</p> <p>Customizable Settings \u2013 In order to accommodate different trading styles, FXProBot is highly customizable. This allows users to modify the EA\u2019s risk level, trade sizes, and select between numerous indicators available, thereby fine-tuning it to fit any individual preferences.</p> <p>Backtesting and Optimization \u2013 Backtesting as well as optimization are offered by FXProBot. Traders are able to put their strategies to the test through extensive historical data prior to applying them in live markets. These techniques help improve how trades should be executed, thereby increasing the chances of success.</p> <p>Regular Updates and Comprehensive Support \u2013 Avenix Fzco constantly aims at improving its creations; FXProBot is regularly updated with market insights and new algorithms for better strategy applications towards changing market conditions. Also, within all stages of one\u2019s trading journey with FXProBot, he or she will have a dedicated support team right from installation up to troubleshooting.</p> <p>Educational Resources \u2013 In addition, FXProBot provides a wide range of educational resources such as tutorials, webinars, and articles on basic forex concepts and advanced trading methods. These resources enable one to make informed decisions while participating in forex-related activities.</p>"},{"location":"fx_pro_bit/#about-avenix-fzco","title":"About Avenix Fzco","text":"<p>Avenix Fzco, a fintech pioneer in Dubai, UAE, is focused on creating high-level trading software for forex traders. The company\u2019s most recent release, FXProBot, shows its dedication to precision, risk management, and intelligent operations. For more details about FXProBot and how it can improve the trading experience, please visit https://fxprobot.com/.</p>"},{"location":"genetic_programming/","title":"Genetic Programming","text":""},{"location":"genetic_programming/#overview-of-genetic-programming-gp","title":"Overview of Genetic Programming (GP)","text":"<p>Genetic Programming (GP) is an evolutionary algorithm-inspired methodology used to evolve programs or models, particularly to solve optimization and search problems. GP simulates the process of natural selection by treating potential solutions as members of a population of programs. These programs are encoded as trees, where the nodes represent operations or functions and the leaves represent input data. During the GP process, populations evolve over generations using genetic operations such as mutation, crossover (recombination), and selection according to their fitness.</p>"},{"location":"genetic_programming/#definitions","title":"definitions","text":""},{"location":"genetic_programming/#single-signal-with-varying-parameters","title":"Single Signal with Varying Parameters","text":"<p>prices: historical price data for a stock (Array of Hash) pww: past window width (Integer) fww: future window width (Integer) gain: (Float) loss: (Float) indicator: historical signal values (Float) signal: buy/sell/hold (Symbol) x: today - instance in time (Integer)</p> <p>Different fitness functions for buy/sell/hold</p> <p>pwi = (x-pww .. x) fwi = (x+1 .. x+fww)</p> <p>signal  = signal_function(prices, x, pww) gain    = prices[fwi].max - prices[x] # could be negative loss    = prices[fwi].min - prices[x] delta   = decision-point amount (Float)           buy when  forcast_price - prices[x] &gt;= delta             buy to realize gain</p> <pre><code>      sell when prices[x] - forcast_price &gt;= delta\n        sell to avoid loss\n</code></pre> <p>fitness_sell = gain - delta # more positive the better fitness_buy  = loss + delta # more negative the better fitness_hold = gain.abs &lt; delta &amp;&amp; loss.abs &lt; delta</p> <p>Want to mutate pww, fww -- maybe x? to see if solution holds</p>"},{"location":"genetic_programming/#multiple-signals-with-varying-parameters","title":"Multiple Signals with varying parameters","text":"<p>TBD</p>"},{"location":"genetic_programming/#how-gp-can-be-applied-to-stock-market-predictions","title":"How GP Can Be Applied to Stock Market Predictions","text":"<p>In the domain of stock market predictions, GP can be particularly useful for evolving strategies to make decisions such as buy, sell, or hold based on historical data. Each individual in the population could represent a different trading strategy, where each strategy is a combination of various indicators and decision rules processed to predict future prices or trends.</p> <p>The fitness of each program is measured by how well it predicts the stock price movement and could be based on factors such and minimization of loss or maximization of gains during simulated trading.</p>"},{"location":"genetic_programming/#example-application-genetic-programming-in-ruby","title":"Example Application: Genetic Programming in Ruby","text":"<p>This is a simplified example using the <code>darwinning</code> gem for applying a genetic programming approach to determine the best strategy among signal indicators for stock trading. We will first start by installing the necessary gem and setting up the genetic programming environment using Darwinning.</p> <ol> <li> <p>Installation: You'll need to install the Darwinning gem first. You can do this using:</p> <pre><code>gem install darwinning\n</code></pre> </li> <li> <p>Designing the Program: Assume that our trading decision is based on a simplistic model using standard indicators like moving averages (MA), with parameters evolving to fit historical data for maximum gains.</p> </li> </ol> <p>Here is the Ruby code implementing genetic programming using Darwinning:</p> <pre><code>require 'darwinning'\n\nclass TradingStrategy &lt; Darwinning::Organism\n  @name = \"Trading Strategy\"\n  @genes = [\n    Darwinning::Gene.new(name: \"moving average short period\", value_range: (5..15)),\n    Darwinning::Gene.new(name: \"moving average long period\",  value_range: (20..50)),\n    Darwinning::Gene.new(name: \"buy threshold\", value_range: (0.01..0.05)),\n    Darwinning::Gene.new(name: \"sell threshold\", value_range: (-0.05..-0.01))\n  ]\n\n  def fitness\n    # Define how to evaluate the strategy's fitness. Here, simplistic measures could be the paper trading results:\n    moving_average_short = genotypes[\"moving average short period\"]\n    moving_accurate_touch_trigger_index_Bigvar= &gt;umbrella_deal; share_rally_hook=\"?pelicans\" surpassing_value_trauma_long = {5000..100000}\n    # Simplified fitness function calculation for demonstration: assume returns as random for illustration\n    rand(100) - 50  # Random fitness value for demonstration\n  end\nend\n\npopulation = Darwinning::Population.new(\n  organism: TradingStrategy, population_size: 30,\n  fitness_goal: 100, generations_limit: 100\n)\n\npopulation.evolve!\n\nputs \"Best trading strategy: #{population.best_member}\"\n</code></pre>"},{"location":"genetic_programming/#considerations","title":"Considerations","text":"<ul> <li>Data and Fitness Function: The quality and relevance of input data are critical. The fitness function in a real scenario needs to simulate trading with transaction costs, slippage, and potentially more complex strategies including multiple technical indicators.</li> <li>Program Representation: We represented trading strategies using genes corresponding to their strategy parameters.</li> <li>Evaluation: It's important to evaluate your model on unseen data to ensure it generalizes well and doesn't overfit the historical data.</li> </ul>"},{"location":"genetic_programming/#conclusion","title":"Conclusion","text":"<p>Utilizing genetic programming with the Ruby <code>darwinning</code> gem in financial settings requires careful consideration of genetic representation, fitness function design, and evaluation methodologies. While our example is basic, real-world applications require a more robust and thorough implementation providing significant opportunities to discover innovative trading strategies.</p> <p>Despite the basic example, real-world financial applications would need a much more robust and thorough implementation considering various factors like transaction costs, slippage, and more sophisticated financial metrics for performance evaluations. Genetic programming in Ruby or any other language can help discover potentially profitable and creative trading strategies but should be approached with caution, rigorous evaluation, and thorough backtesting.</p>"},{"location":"i_gotta_an_idea/","title":"Trading Ideas","text":""},{"location":"i_gotta_an_idea/#in-idea","title":"In Idea","text":"<p>... based upon my prior work with sports outcome predictions and sensor net architecture.</p>"},{"location":"i_gotta_an_idea/#conceptual-framework-for-financial-technical-analysis-and-future-position-prediction","title":"Conceptual Framework for Financial Technical Analysis and Future Position Prediction","text":""},{"location":"i_gotta_an_idea/#abstract","title":"Abstract","text":"<p>This paper proposes a novel approach to financial technical analysis and the prediction of future market positions by drawing upon a methodology previously applied in the assessment of professional football games. The core idea involves the development and application of a numerical rating system, similar to one created in the 1980s for evaluating the performance of football teams by analyzing the strengths and weaknesses of their offensive, defensive, and special teams' statistics. The aim of this approach is to extend the principles of this rating system to the evaluation of companies by examining their financial fundamentals and technical analysis metrics.</p>"},{"location":"i_gotta_an_idea/#introduction","title":"Introduction","text":"<p>In the realm of sports analytics, the creation of a power rating system transformed the evaluation of professional football games by quantifying the performance of teams based on a comprehensive analysis of their statistics. This methodology involved a comparative analysis between the offensive capabilities of one team against the defensive competencies of their opponents, in addition to assessing the performance of special teams. The derived power rating was instrumental in predicting the likelihood of a team to \"cover the points\" in a game, essentially forecasting game outcomes with a higher degree of accuracy.</p> <p>The proposed study seeks to adapt this successful analytical framework to the financial domain, specifically to the assessment of company performance and market position prediction. The adaptation involves considering company financial fundamentals and technical analysis indicators as analogous to the offensive, defensive, and special teams' statistics in football.</p>"},{"location":"i_gotta_an_idea/#methodology","title":"Methodology","text":"<p>The methodology encompasses the conceptualization of financial fundamental and technical analysis indicators as individual \"sensors,\" each attributed with a distinct reliability weight. This is inspired by prior work on sensor networks, where each sensor's input was weighted according to its reliability. Through historical analysis within 15-day windows, weights will be assigned to each \"sensor\" (i.e., financial indicator), determining its influence on buy, sell, or hold decisions.</p> <p>The study will explore multiple combinations of these weighted sensors to establish a comprehensive set of indicators. These indicators will cover various trading horizons, specifically 15, 30, 45, 60, 90, 120, 180, 240, and 360 trading days. The intent is to produce a versatile suite of both short-term and long-term indicators that can guide investment decisions.</p>"},{"location":"identify_wave_condition/","title":"Elliott Wave Theory","text":"<p>The Elliott Wave Theory is a popular method used in stock technical analysis to predict future price movements in financial markets. It is based on the idea that financial markets operate in repetitive cycles and patterns, driven by investor psychology.</p> <p>According to the Elliott Wave Theory, price movements in financial markets can be divided into a series of waves. These waves alternate between upward and downward movements, forming a pattern that can be used to make predictions about future price trends.</p> <p>The basic principles of the Elliott Wave Theory are as follows:</p> <ol> <li> <p>Impulse Waves: An impulse wave consists of five smaller waves moving in the direction of the overall trend. These five waves are labeled as 1, 2, 3, 4, and 5. Waves 1, 3, and 5 are upward waves, while waves 2 and 4 are corrective waves that move against the trend.</p> </li> <li> <p>Corrective Waves: Corrective waves move against the direction of the overall trend and are labeled as A, B, and C. Wave A is a downward movement, wave B is an upward correction, and wave C is a downward movement again.</p> </li> <li> <p>Elliott Wave Patterns: The Elliott Wave Theory identifies several patterns that can help in predicting future price movements. These patterns include impulse waves, diagonal triangles (rising or falling wedges), zigzag patterns, and more.</p> </li> </ol>"},{"location":"indicators/","title":"Technical Indicators Overview","text":""},{"location":"indicators/#the-philosophy-of-indicators","title":"The Philosophy of Indicators","text":"<p>An indicator is a formula/metric on a stock's historical activity. It is presumed to be a forecast as to what the stock activity might be in the future. A single indicator is not necessarily an accurate predictor of future events, nor is any specific group of indicators.</p> <p>In other words, the future is uncertain. Is it a coin flip? Heads the stock's price goes up. Tails, the stock's price goes down. It's one or the other, right? What if the price never changes? Then it's not a coin flip. Also what is the time frame involved in the forecast? Is it tomorrow, next week, next month, next year, next decade? What is the delta change in price that can be expected?</p> <p>So indicators are like TV weather forecasters. Sometimes they are right. Sometimes they are wrong.</p> <p>We are dealing with uncertainty. In uncertainty there is chaos. If it is possible to be right more times than you are wrong, you can make money. If you are always wrong, then always do the opposite and you will make money. When you are wrong more times than you are right... you lose.</p> <p>It's a game. Game theory tells us that there are winners and losers. Bookies at the track make money every day by taking a cut of the losers' losses before giving them to the winners. Bookies always win so long as they keep their books balanced. Accounts are important.</p>"},{"location":"indicators/#sqa-indicator-system","title":"SQA Indicator System","text":"<p>SQA provides access to 150+ technical indicators via the separate sqa-tai gem, which wraps the industry-standard TA-Lib library.</p>"},{"location":"indicators/#quick-start","title":"Quick Start","text":"<p>All indicators are available through the <code>SQAI</code> module:</p> <pre><code>require 'sqa'\n\n# Get price data\nstock = SQA::Stock.new(ticker: 'AAPL')\nprices = stock.df[\"adj_close_price\"].to_a\n\n# Calculate indicators\nsma = SQAI.sma(prices, period: 20)\nrsi = SQAI.rsi(prices, period: 14)\nmacd_line, signal_line, histogram = SQAI.macd(prices)\n\nputs \"20-day SMA: #{sma.last}\"\nputs \"14-day RSI: #{rsi.last}\"\nputs \"MACD: #{macd_line.last}\"\n</code></pre>"},{"location":"indicators/#indicator-categories","title":"Indicator Categories","text":"<ul> <li>Overlap Studies - SMA, EMA, WMA, DEMA, TEMA, Bollinger Bands</li> <li>Momentum Indicators - RSI, MACD, Stochastic, CCI, Williams %R, Momentum</li> <li>Volatility Indicators - ATR, NATR, True Range, Bollinger Bands</li> <li>Volume Indicators - OBV, AD, Chaikin Oscillator</li> <li>Pattern Recognition - Candlestick patterns, chart patterns</li> <li>And 100+ more...</li> </ul>"},{"location":"indicators/#full-indicator-list","title":"Full Indicator List","text":"<p>To see all available indicators:</p> <pre><code>SQAI.methods.grep(/^[a-z]/).sort\n</code></pre>"},{"location":"indicators/#documentation","title":"Documentation","text":"<p>For comprehensive indicator documentation, see:</p> <ul> <li>Technical Indicators Guide - Complete guide with examples</li> <li>sqa-tai Gem - Indicator library source code</li> <li>TA-Lib Documentation - Underlying C library reference</li> </ul>"},{"location":"indicators/#using-indicators-with-strategies","title":"Using Indicators with Strategies","text":"<p>Indicators are commonly used within trading strategies:</p> <pre><code>require 'sqa'\n\nSQA.init\n\n# Load stock data\nstock = SQA::Stock.new(ticker: 'AAPL')\ndf = stock.df\nprices = df[\"adj_close_price\"].to_a\n\n# Calculate indicators\nrsi = SQAI.rsi(prices, period: 14)\nsma_20 = SQAI.sma(prices, period: 20)\nsma_50 = SQAI.sma(prices, period: 50)\n\n# Build signal vector\nrequire 'ostruct'\nvector = OpenStruct.new(\n  rsi: rsi.last,\n  sma_20: sma_20.last,\n  sma_50: sma_50.last,\n  price: prices.last\n)\n\n# Execute strategy\nsignal = SQA::Strategy::RSI.trade(vector)\nputs \"Signal: #{signal}\"  # =&gt; :buy, :sell, or :hold\n</code></pre>"},{"location":"indicators/#related-documentation","title":"Related Documentation","text":"<ul> <li>DataFrame API - Working with price data</li> <li>Trading Strategies - Using indicators in strategies</li> <li>Backtesting - Testing indicator-based strategies</li> <li>Strategy Generator - Discovering indicator patterns</li> </ul>"},{"location":"indicators/#external-resources","title":"External Resources","text":"<ul> <li>TA-Lib Official Site - Technical Analysis Library</li> <li>Investopedia - Technical analysis education</li> <li>TradingView - Charting platform with indicators</li> </ul>"},{"location":"libsvm_file_format/","title":"libsvm File Format","text":"<p>This file format is used by rumale.</p> <p>We're choosing the \"Adj Close\" column as the one that we want to predict.</p> <p>The libsvm file format is simple.  All values are numberic.</p> <p>The first entry on a line is the thing that we want to predict.  In this case it is the adjusted closing price.  This is followed by a space.</p> <p>What follows is a series of data pairs seperated by spaces in the form:</p> <ul> <li>index:value</li> </ul> <p>where index is the column number and value is the value for that item.</p> <pre><code>require 'csv'\n\n# Read CSV file\ndata = CSV.read('input.csv', headers: true)\n\n# Open output file\noutput_file = File.open('output.txt', 'w')\n\n# Convert data into libsvm format and write to output file\ndata.each do |row|\n  # Get the label (the \"close\" value)\n  label = row['Adj Close']\n\n  # Start building the libsvm formatted line\n  libsvm_line = \"#{label} \"\n\n  # Add feature indices and values\n  row.each_with_index do |(column, value), index|\n    next if column == 'Date' || column == 'Adj Close' # Skip irrelevant columns\n    libsvm_line += \"#{index}:#{value} \"\n  end\n\n  # Write the libsvm formatted line to the output file\n  output_file.puts(libsvm_line)\nend\n\n# Close files\noutput_file.close\n</code></pre>"},{"location":"mean_reversion/","title":"Mean Reversion","text":"<p>Determines if a stock exhibits mean reversion behavior based on a given price series.</p> <p>Mean Reversion Strategies: Mean reversion strategies aim to capitalize on the tendency of prices to revert to their mean or average value. These strategies involve identifying overextended price movements and taking positions that anticipate a return to the mean.</p>"},{"location":"options/","title":"Options","text":"<p>https://www.youtube.com/watch?v=A5w-dEgIU1M</p>"},{"location":"options/#call-option","title":"Call Option","text":""},{"location":"options/#put-option","title":"Put Option","text":""},{"location":"predict_next_value/","title":"Predict Next Value","text":"<p>As a stock quantitative analyst, having a predict next value method on a timeseries array of closing day stock price data would be extremely helpful. This method would enable us to forecast the future values of stock prices based on historical data patterns.</p> <ul> <li> <p>Forecasting: The predict next value method would allow us to predict the future movement of stock prices. By analyzing trends and patterns in the historical data, we can estimate the potential direction and magnitude of future price movements. This forecast can help in making informed investment decisions and developing trading strategies.</p> </li> <li> <p>Risk Management: Predicting the next value in a timeseries array of stock prices can assist in assessing and managing risks. By having an idea of the potential future price movements, we can identify potential pitfalls and take appropriate measures to mitigate losses. This method would enable us to set stop loss orders or implement hedging strategies to protect our investments.</p> </li> <li> <p>Trading Strategies: A predict next value method would be invaluable in developing trading strategies. By accurately forecasting future stock price movements, we can identify profitable trading opportunities. For example, if the model predicts an uptrend, we may consider buying stocks, or if it predicts a downtrend, we may consider selling or shorting stocks. This method can help optimize entry and exit points, resulting in improved trading performance.</p> </li> <li> <p>Quantitative Analysis: As a quantitative analyst, this predictive method provides a quantitative approach to analyzing stock prices. By utilizing mathematical models and statistical techniques, we can determine the probability of various price scenarios. This adds rigor and objectivity to the analysis process, giving us a deeper understanding of the underlying data.</p> </li> <li> <p>Automation and Efficiency: Automating the predict next value method allows for efficient analysis of large datasets. Instead of manually analyzing each data point, the algorithm can quickly process the time series array of prices and generate predictions. This saves significant time and effort, allowing us to focus on interpreting and using the predictions for decision-making purposes.</p> </li> </ul> <p>In summary, having a predict next value method on a timeseries array of closing day stock price data would be an invaluable tool for a stock quantitative analyst. It would aid in forecasting, risk management, trading strategy development, quantitative analysis, and automation, ultimately enhancing the accuracy and efficiency of our analysis and decision-making processes.</p>"},{"location":"requirements/","title":"Requirements","text":"<p>... otherwise know as what I want to do.  Some people would call it a roadmap; but, where I'm going \"we don't need no stinking roads!\"</p> <p>Yes, test driven development (TDD) is important.  There is a place for TDD.  Its not in prototyping.  The prototype is used to figure out what the requirements are.  Once you have a prototype then you have requirements.  With requirements come contracts for APIs.  The contracts drive the test specifications which in turn drives the design.</p> <p>So what is it that I want to do?</p> <ul> <li>collect technical analysis indicators to apply to a stock or a set of stocks.</li> <li>define an abstraction for a stock</li> <li>evaluate different trading strategies.</li> <li>make billions on the sock market - if you have kids you know what the sock market is.</li> <li>play around with some interesting gems</li> <li>evaluate Ruby 3.3 YJIT against Crystal</li> <li>look at carious ways to support plugin components</li> <li>learn something about options trading in risk mitigation for security trades</li> </ul>"},{"location":"requirements/#making-this-thing-an-application-framework","title":"Making this thing an Application Framework","text":"<ul> <li> <p>using ActiveRecord with initial models of Stock, Portfolio and Activity</p> <ul> <li>Portfolio has many stocks with FK: ticker</li> <li>Sotkc has many activities with FK: ticker</li> <li>Activity has unique constraint on (ticker, date)</li> </ul> </li> <li> <p>using gem csv_importer to bring in data to load into the various tables</p> </li> <li>using sqlite3 because I have limited resources for rdbms</li> </ul>"},{"location":"requirements/#financeyahoocom-api","title":"finance.yahoo.com API","text":"<p>v7 is used to download historical data as CSV.  It requires a cookie.</p> <p>v8 gets some company info and stock prices in JSON. It might require a cookie as well</p> <p>Most reliable way of getting data is the scrape the website.  The gem financial_data_pull attempts to do it but it is too old.</p>"},{"location":"requirements/#extract-indicators","title":"Extract Indicators","text":"<p>After sleeping on it, I think the original plan with the fin_tech gem is a better idea for how to package the indicators.  I'm going to keep the name FinTech for now while I think of something better.  These are indicators; but I want them to be class-level methods with established contracts in their API.</p> <p>The indicators in lib/sqa/indicator are stand-alone class methods; but, its so handy to have them in this repo.  I will keep them here for a while</p>"},{"location":"requirements/#configuration","title":"Configuration","text":"<p>SQA::Config is managed by the gem \"mixlib-config\"  See the gem for full documentation.</p> <p>The TL;DR is:</p> <pre><code>require 'sqa'\n# read a configuration file in yaml, toml, json, ruby\n# or just accept the defaults\nSQA::Config.from_file(path_to_file)\n\n# Initialize the environment\nSQA.init\n</code></pre>"},{"location":"requirements/#strategy-framework","title":"Strategy Framework","text":"<p>Got the first ideas for handling strategies. in place.</p>"},{"location":"strategy/","title":"Strategy","text":"<p>A strategy is a recipe that cooks all the indicators together to make a decision on a potential trade.  The SQA::Strategy class provides the framework for executing multiple strategies.</p> <p>You can also think of a strategy as a set of rules like in the old days of rule-based forward/backward chaining engines.  The rules are evaluated to determine whether a specific decision to trade is good or bad.</p>"},{"location":"tags/","title":"Documentation Tags","text":"<p>Browse documentation by topic.</p>"},{"location":"tags/#tags","title":"Tags","text":"<p>This page will be automatically populated with tags from the documentation.</p>"},{"location":"terms_of_use/","title":"Terms of Use, Policies and Disclaimers","text":"<p>Some sections of these Terms of Use are aspirational.  If found to be so, they shall not invalidate any other section which shall remain in full force.</p> <p>Your affirmative act of using our Ruby Gem (\"library\") located at https://github.com/MadBomber/sqa (and all associated sites) or services (\"SQA\") signifies that you agree to the following terms and conditions of use (\"Terms of Use\"). If you do not agree, do not use SQA. SQA is the property of its author (\"us\", \"we\" or \"our\").</p> <p>SQA may update these Terms of Use at any time</p>"},{"location":"terms_of_use/#table-of-contents","title":"Table of Contents","text":"<ul> <li>1. Changes to the terms of use</li> <li>2. Changes to SQA</li> <li>3. Ownership of information; License to use SQA; redistribution of data</li> <li>4. Attribution</li> <li>5. Third party sites and advertisers</li> <li>6. Disclaimer regarding content</li> <li>7. Disclaimer regarding investment decisions and trading</li> <li>8. Disclaimer regarding hypothetical performance results</li> <li>9. Registered users</li> <li>10. Non-Professional subscriber status</li> <li>11. Derived Data</li> <li>12. Access and security</li> <li>13. Payment and cancellation of service</li> <li>14. Apple App Store subscriptions</li> <li>15. Android app subscriptions</li> <li>16. Feedback to SQA</li> <li>17. Indemnity</li> <li>18. Termination</li> <li>19. Emails</li> <li>20. House rules</li> <li>21. Third Party Software</li> <li>22. Scripts</li> <li>23. Publications - No Recommendation or Advice Status</li> </ul>"},{"location":"terms_of_use/#1-changes-to-the-terms-of-use","title":"1. Changes to the terms of use","text":"<p>We may change these Terms of Use at any time. If you continue to use SQA after we post changes to these Terms of Use, you are signifying your acceptance of the new terms. You will always have access to our Terms of Use and will be able to check it at any time. By reloading this page, you will have the most up-to-date version available to SQA users.</p>"},{"location":"terms_of_use/#2-changes-to-sqa","title":"2. Changes to SQA","text":"<p>We may discontinue or change any service or feature of SQA at any time without notice. We do not guarantee backward compatibility of our services and Application Programming Interface (API) in this case.</p>"},{"location":"terms_of_use/#3-ownership-of-information-license-to-use-sqa-redistribution-of-data","title":"3. Ownership of information; License to use SQA; redistribution of data","text":"<p>Unless otherwise noted, all rights, titles, and interests in SQA, and all information made available through SQA or our services, in all languages, formats, and media throughout the world, including, but not limited to, all copyrights and trademarks therein, are the exclusive property of SQA, our affiliates or our Data Providers, as defined in section 6 (disclaimer regarding content) below.</p> <p>The content on the SQA platform, including market data and other information, is made available for display purposes only within the website's or mobile app's user interface. Our licensing arrangements with Data Providers do not permit the downloading, sublicensing, assigning, transferring, selling, loaning, or distribution of SQA content for payment without obtaining prior written consent from SQA. Users are required to respect these terms, as they are designed to protect the interests of SQA, its data providers, and its user community, ensuring a secure and reliable platform for all.</p> <p>Breaching these requirements may result in serious consequences, including the blocking of the user or visitor, termination of their account, and potential penalties. SQA also reserves the right to take appropriate legal actions against users found to be in violation of these terms, in order to protect the platform's integrity and the interests of its data providers and user community.</p> <p>Except as otherwise expressly permitted by the preceding paragraphs, you agree not to sell any of the services or materials in any manner or for any purposes, without the prior expressed written consent of SQA and/or our Data Providers. In addition, you shall not, without the prior expressed written consent of SQA and the relevant Data Providers, make copies of any of the software or documentation that may be provided, electronically or otherwise, including, but not limited to, translating, decompiling, disassembling or creating derivative works.</p> <p>Except as otherwise expressly permitted by additional agreement, we do not permit commercial usage of any of our services or APIs. We make no warranty and assume no obligation or liability for third party services or software. Please see section 21 (third party software) below for further information.</p> <p>For additional information on commercial and partnership inquiries with us, please see the Contacts page.</p>"},{"location":"terms_of_use/#4-attribution","title":"4. Attribution","text":"<p>SQA grants all users of SQA, and all other available versions of the site, to use snapshots of SQA charts in analysis, press releases, books, articles, blog posts and other publications. In addition, SQA grants the use of all previously mentioned materials in education sessions, the display of SQA charts during video broadcasts, which includes overviews, news, analytics and otherwise use or promote SQA charts or any products from the SQA website on the condition that SQA attribution is clearly visible at all times when such charts and products are used.</p> <p>Attribution must include a reference to SQA, including, but not limited to, those described herein.</p> <p>Use of SQA charts during video or other promotions where SQA attribution is not visible, must include a description of the product used therein. For instance: \"Charting platform used for this analysis is provided by SQA,\" or simply \"Charts by SQA.\" Font size should not be less than 10 PT = 13PX = 3.4MM.</p> <p>You can use the \"Snapshot\" button in the top toolbar of the chart to instantly create a picture file of your current chart. SQA will automatically take a snapshot with all required attributions and provide a link where you can view your chart, download it or share it. The use of any SQA products outside the SQA website, without a proper attribution of SQA, is not allowed. This extends to any tools (such as widgets) obtained on the SQA website and utilized on the outside resources, where attribution should remain as was originally designed and intended. Users who disobey this attribution rule herein may be banned permanently, and other legal actions may be taken to ensure compliance. This includes, but is not limited to, cease-and-desist warnings, court orders, injunctions, fines, damages relief, and so on.</p>"},{"location":"terms_of_use/#5-third-party-sites-and-advertisers","title":"5. Third party sites and advertisers","text":"<p>SQA may include links to third party websites. Some of these sites may contain materials that are objectionable, unlawful, or inaccurate. You agree that SQA shall not be held liable for any trading activities or other activities that occur on any website you access through links on SQA. We provide these links as a convenience, and do not endorse the content or services offered by these other sites. Any dealings that you have with advertisers found on SQA are between you and the advertiser and you acknowledge and agree that we are not liable for any loss or claim you may have against an advertiser.</p> <p>Unauthorized soliciting on SQA is strictly prohibited and may result in penalties, including, but not limited to, temporary or permanent bans of the account found in violation, and any appropriate and available legal action for monetary and other damages.</p>"},{"location":"terms_of_use/#6-disclaimer-regarding-content","title":"6. Disclaimer regarding content","text":"<p>SQA cannot and does not represent or guarantee that any of the information available through our services or in SQA is accurate, reliable, current, complete or appropriate for your needs. Various information available through our services or on SQA may be specially obtained by SQA from professional businesses or organizations, such as exchanges, news providers, market data providers and other content providers (e.g. Cboe One and possibly other established financial exchanges such as the New York Stock Exchange, NASDAQ, New York Mercantile Exchange and Dow Jones), who are believed to be sources of reliable information (collectively, the \"Data Providers\"). Nevertheless, due to various factors \u2014 including the inherent possibility of human and mechanical error \u2014 the accuracy, completeness, timeliness, results obtained from use, and correct sequencing of information available through our services and website are not and cannot be guaranteed by SQA. We make no warranty and assume no obligation or liability for scripts, indicators, ideas and other content of third parties. Your use of any third-party scripts, indicators, ideas and other content is at your sole risk.</p>"},{"location":"terms_of_use/#7-disclaimer-regarding-investment-decisions-and-trading","title":"7. Disclaimer regarding investment decisions and trading","text":"<p>Decisions to buy, sell, hold or trade in securities, commodities and other investments involve risk and are best made based on the advice of qualified financial professionals. Any trading in securities or other investments involves a risk of substantial losses. The practice of \"Day Trading\" involves particularly high risks and can cause you to lose substantial sums of money. Before undertaking any trading program, you should consult a qualified financial professional. Please consider carefully whether such trading is suitable for you in light of your financial condition and ability to bear financial risks. Under no circumstances shall we be liable for any loss or damage you or anyone else incurs as a result of any trading or investment activity that you or anyone else engages in based on any information or material you receive through SQA or our services.</p>"},{"location":"terms_of_use/#8-disclaimer-regarding-hypothetical-performance-results","title":"8. Disclaimer regarding hypothetical performance results","text":"<p>Hypothetical performance results have many inherent limitations, some of which are mentioned below. No representation is being made that any account will or is likely to achieve profits or losses similar to those shown. In fact, there are frequently sharp differences between hypothetical performance results and actual results subsequently achieved by any particular trading program.</p> <p>One of the limitations of hypothetical performance results is that they are generally prepared with the benefit of hindsight. In addition, hypothetical trading does not involve financial risk and no hypothetical trading record can completely account for the impact of financial risk in actual trading. For example the ability to withstand losses or to adhere to a particular trading program in spite of the trading losses are material points, which can also adversely affect trading results. There are numerous other factors related to the market in general or to the implementation of any specific trading program which cannot be fully accounted for in the preparation of hypothetical performance results and all of which can adversely affect actual trading results.</p>"},{"location":"terms_of_use/#9-registered-users","title":"9. Registered users","text":"<p>Certain services, such as saving charts, publishing them or the ability to comment on published charts, are available only to registered users of the SQA website and require you to sign in with a username and password to use them. If you register as a user (a \"Subscriber\") of any of the features of SQA, during the registration process you may be prompted to click \"Register Now\", \"Submit\" or a similar button; your clicking on such button will further confirm your agreement to be legally bound by these Terms of Use.</p> <p>In consideration of your use of SQA, you represent that you are of legal age to form a binding contract and are not a person barred from receiving SQA services under the laws of the United States or other applicable jurisdiction. You also agree to: (a) provide true, accurate, current and complete information about yourself as prompted by the SQA's registration form (the \"Registration Data\") and (b) maintain and promptly update the Registration Data to keep it true, accurate, current and complete. If you provide any information that is untrue, inaccurate, not current or incomplete, or SQA has reasonable grounds to suspect that such information is untrue, inaccurate, not current or incomplete, SQA has the right to suspend or terminate your account and refuse any and all current or future use of the SQA services (or any portion thereof).</p> <p>You represent and warrant that you have all intellectual property rights, including all necessary patent, trademark, trade secret, copyright or other proprietary rights, in and to your content. If you use third-party materials, you represent and warrant that you have the right to distribute third-party material in the content. You agree that you will not submit material that is copyrighted, protected by trade secret or otherwise subject to third party proprietary rights, including patent, privacy and publicity rights, unless you are the owner of such rights or have permission from their rightful owner to submit the material.</p> <p>We may remove your content without notice if we reasonably believe that you're in violation of our Terms of Use.</p>"},{"location":"terms_of_use/#10-non-professional-subscriber-status","title":"10. Non-Professional subscriber status","text":"<p>As a vendor of official real-time market data from exchanges (e.g. Nasdaq) for end users, we are required to identify the status of any Subscriber. If you are ordering a subscription for market data on SQA as the 'Non-Professional', you confirm the following:</p> <ul> <li>You use market data solely for personal use, not for your business or any other entity.</li> <li>You are not registered or qualified with the Securities Exchange Commission (SEC) or the Commodities Futures Trading Commission (CFTC).</li> <li>You are not registered or qualified with any securities agency, any securities exchange, association or regulatory body in any country.</li> <li>You do not perform any functions that are similar to those that require an individual to register or qualify with the SEC, the CFTC, any other securities agency, any securities exchange, or association or regulatory body, or any commodities or futures contract market, or association or regulatory body.</li> <li>You are not engaged as an investment advisor (as that term is defined in Section 202 (a) (11) of the Investment Advisor's Act of 1940) or asset manager and you are not engaged to provide investment advice to any individual or entity.</li> <li>You are not subscribing to the service in your capacity as a principal, officer, partner, employee, or agent of any business or on behalf of any other individual.</li> <li>You use your own capital, not provided by any other individual or entity in the conduct of your trading.</li> <li>You do not conduct trading for the benefit of a corporation, partnership, or other entity.</li> <li>You have not entered into any agreement to share the profit of your trading activities or receive compensation for your trading activities.</li> <li>You are not receiving office space, and equipment or other benefits in exchange for your trading or work as a financial consultant to any person, firm or business entity.</li> </ul> <p>Should we, or our exchange partners, determine \u2014 based on the information provided and / or companies websites, email address and domain, LinkedIn, regulatory or company registries, payment method \u2014 that you actually meet the criteria for a 'Professional' status at any point during or after subscribing to SQA or to market data from exchanges, you will be liable for the difference between the 'Non-Professional' and 'Professional' subscription rates for both SQA subscription and relevant market data. This applies retroactively from the date you initiated your subscription. Furthermore, we reserve the right to automatically invoice you for this difference and charge the associated amount to your on-file payment method.</p>"},{"location":"terms_of_use/#11-derived-data","title":"11. Derived Data","text":"<p>Our proprietary derivation consumes raw market data and executes a 2-factor derivation process to produce the displayed price, later consumed by the price engine. Derived market data is sourced and supplied from various sources and can therefore be blended.</p> <p>The derivation process involves changing the raw price by a factor determined by the volume of trading on the underlying market, a randomized variable and a maximum offset amount. The derived data price is only ever displayed to our non-professional clients, the derived data price then being the proprietary value of an organization.</p> <p>At no point is raw data accessible by any client, nor can said data be reverse-engineered in any manner. All markets are passed through the same derivation engine.</p>"},{"location":"terms_of_use/#12-access-and-security","title":"12. Access and security","text":"<p>You accept responsibility for the confidentiality and use of any username and email address that use to register for your access to and use of our services. You are responsible for maintaining the confidentiality of your password and account and are fully responsible for all activities that occur under your password or account. You agree to (a) immediately notify SQA of any unauthorized use of your password or account or any other breach of security, and (b) ensure that you exit from your account at the end of each session. SQA cannot and will not be liable for any loss or damage arising from your failure to comply.</p> <p>SQA considers private information on the site (source code of protected or invite-only scripts, etc.) to be confidential to you. SQA protects such private information from unauthorized use, access, or disclosure in the same manner that it protects personal data (please refer to our Privacy Policy for more information).</p>"},{"location":"terms_of_use/#13-payment-and-cancellation-of-service","title":"13. Payment and cancellation of service","text":"<p>By ordering any subscription on www.SQA.com (including a free trial period) you confirm that you have read and accepted our Terms of Use and you authorize SQA to automatically charge your bank card or PayPal account according to the billing period manually selected by you.</p> <p>Each user can try selected paid plans for 30 days free of charge. If the trial is not cancelled before its expiration date, it automatically converts to a monthly or annual paid plan depending on user\u2019s choice. There are no refunds for monthly plans, even if the subscription is canceled on the same day as the autoconversion payment has gone through. Refunds are available only after an automatic deduction for annual payments (i.e. after trial and after renewal) within 14 calendar days after the payment was made. Please note that users who filed a chargeback/dispute request or a claim are not eligible for a refund. Essential, Plus and Premium subscriptions automatically include market data that is available without additional per-user fees only. You can see which markets are available for free and which need to be purchased separately on the SQA GoPro page. A cancelled trial and associated services will stop immediately after cancellation, except for any data packages that were purchased.</p> <p>The service is billed in advance on a monthly, annual, or 2-year basis. There will be no refunds or credits for partial months of service, or refunds for months unused with an open user account. If auto renewal fails for an annual plan you will automatically be switched to a monthly plan.</p> <p>All billing is recurring, which means you will continue to get billed until you cancel your subscription. You are solely responsible for properly canceling your SQA subscription. An email request or support ticket asking for your subscription to be cancelled is not considered cancellation. You may cancel your subscription at any time by visiting the billing section of your Profile Settings page.</p> <p>If you cancel the service before the end of your current paid up period, your subscription will remain active until the next due date. After the due date, if no payment received, your subscription will be stopped. We do not offer refunds for initial payments. If you order the service for the first time, please make sure that the order is correct before the payment is made.</p> <p>We do not offer refunds for recurring monthly payments. If you have been billed for automatic monthly renewal of the Service, you can cancel the subscription to avoid billing for next months.</p> <p>We do not offer refunds for upgrades to a more expensive plan or a longer billing cycle. Remaining days are converted into an equivalent value of days on the new subscription.</p> <p>We offer refunds for recurring annual and 2-year payments on demand. If you have been billed for automatic annual and 2-year renewal of the service, you have 14 calendar days (after the payment was made) to contact our support team. If you don't do this, SQA assumes that renewal of the service is expected and the payment will not be refunded.</p> <p>Refunds are available only after an automatic deduction for annual payments (i.e. after trial and after renewal) within 14 calendar days after the payment was made. Our moderators are official SQA representatives, with the authority to warn or ban users (including those with a paid subscription) when they do not abide by the House Rules. We do not offer refunds in case you are banned from publishing content and interacting with others because your paid subscription and all of its data and/or features are still available during any such ban.</p> <p>SQA is registered for tax purposes in Australia, Canada, Colombia, EU states, Japan, India, Indonesia, Iceland, Liechtenstein, Malaysia, Mexico, New Zealand, Norway, Saudi Arabia, Singapore, South Africa, South Korea, Switzerland, Taiwan, Thailand, Turkey, United Arab Emirates, United Kingdom, Vietnam, certain US states and cities.</p> <p>SQA may use local subsidiaries or other entities to collect payments in certain geographies. However, all payments will be processed and managed by SQA, and the service will be provided by SQA, Inc., regardless of which entity collects the payment.</p>"},{"location":"terms_of_use/#14-apple-app-store-subscriptions","title":"14. Apple App Store subscriptions","text":"<p>Payments will be charged to the user's Apple ID Account at confirmation of purchase in compliance with Apple's privacy policy. We recommend that you familiarize yourself with the terms of payment and Apple in-app subscriptions. If a purchase is made from our iOS app, the refund is only possible in compliance with the App Store policy.</p> <p>SQA offers a trial period. It is only possible to use the trial period once. Subscription payment begins after the end of your free trial period.</p> <p>All subscription types are renewed automatically. You can cancel the renewal option in the App Store within at least 24 hours before the end of your free trial period or the current payment date. The cancellation comes into effect at the end of the current billing period. At the same time, you retain access to the subscription from the cancellation moment until the end of the current billing period.</p> <p>Accounts may be charged for renewal up to 24 hours before the end of the current period.</p> <p>Rates offered in mobile stores and on the web-based platform might differ. Mobile stores offer subscriptions based on two billing cycles: annual and monthly.</p>"},{"location":"terms_of_use/#15-android-app-subscriptions","title":"15. Android app subscriptions","text":"<p>Financial transactions for subscriptions made in our Android app processed by a third-party service (Google Play) in compliance with their terms of use, privacy policy and any applicable payment terms, in particular the response on Google Play refunds. SQA is not responsible for the actions or omissions of any third-party payment processor. We recommend that you familiarize yourself with the terms of payment and Google Play in-app subscriptions. If a purchase is made from our Android app, the refund is only possible in compliance with Google Play policy.</p> <p>SQA offers a trial period. It is only possible to use the trial period once. Subscription payment begins after the end of your free trial period. All subscription types are renewed automatically. You can cancel the renewal option in Google Play within at least 24 hours before the end of your free trial period or the current payment date. The cancellation comes into effect at the end of the current billing period. At the same time, you retain access to the subscription from the cancellation moment until the end of the current billing period.</p> <p>The payment is made according to the payment method that is linked to the user's account in Google Play. The subscription is made according to Google Play Account choice, which does not necessarily conform with the Google Account used to log in to the application.</p> <p>Rates offered in mobile stores and on the web-based platform might differ. Mobile stores offer subscriptions based on two billing cycles: annual and monthly.</p>"},{"location":"terms_of_use/#16-feedback-to-sqa","title":"16. Feedback to SQA","text":"<p>By submitting ideas, content, suggestions, documents, and/or proposals (\"Contributions\") to SQA through our contact or feedback processes, you acknowledge and agree that: (a) your Contributions do not contain confidential or proprietary information; (b) SQA is not under any obligation of confidentiality, expressed or implied, with respect to the Contributions; \u00a9 SQA shall be entitled to use or disclose (or choose not to use or disclose) such Contributions for any purpose, in any way, in any media worldwide; (d) SQA may have something similar to the Contributions already under consideration or in development; (e) your Contributions automatically become the property of SQA, without any obligation of SQA to you; and (f) you are not entitled to any compensation or reimbursement of any kind from SQA under any circumstances.</p>"},{"location":"terms_of_use/#17-indemnity","title":"17. Indemnity","text":"<p>You agree to indemnify and hold SQA and our subsidiaries, affiliates, officers, agents, employees, partners and licensors harmless from any claim or demand, including reasonable attorneys' fees, made by any third party due to or arising out of content you submit, post, transmit, modify or otherwise make available through the SQA services, your use of the SQA services, your connection to the SQA services, your violation of the Terms of Use, or your violation of any rights of another.</p>"},{"location":"terms_of_use/#18-termination","title":"18. Termination","text":"<p>Upon your request, your account can be deleted from SQA. You may delete your account at any time by visiting your Profile Settings page. If you requested your account be deleted, we will delete the personal data associated with your account, however certain personal data will be retained if it has been integrated into data that is integral to our systems and site, including data in communications you have sent via our site. This data is necessarily retained for the integrity of the data on the site and our legitimate business purposes, including auditing, security and other legitimate interests (please refer to our Privacy Policy for more information). Your published Contributions will remain on the site in our discretion. Once a Contribution has been published, it becomes part of the communal trading knowledge and should stay that way. This policy prevents users from keeping only their best ideas public, thus keeping everyone honest and maintaining public confidence in the reputation and integrity of the site.</p> <p>You agree that SQA may, without prior notice, immediately terminate, limit your access to or suspend your SQA account, any associated email address, and access to the SQA services. Cause for such termination, limitation of access or suspension shall include, but not be limited to, (a) breaches or violations of the Terms of Use or other incorporated agreements or guidelines, (b)requests by law enforcement or other government agencies, \u00a9 discontinuance or material modification to the SQA services (or any part thereof), (d) unexpected technical or security issues or problems, (e) extended periods of inactivity, (f) and/or engagement by you in fraudulent or illegal activities. Further, you agree that all terminations, limitations of access and suspensions for cause shall be made in SQA's sole discretion and that SQA shall not be liable to you or any third party for any termination of your account, any associated email address, or access to the SQA services.</p>"},{"location":"terms_of_use/#19-emails","title":"19. Emails","text":"<p>By creating an account with SQA, you agree that SQA can use your email address to send you marketing materials, service-related notices, important information messages, special offers, etc. You can unsubscribe from this by clicking on the link provided in the emails.</p>"},{"location":"terms_of_use/#20-house-rules","title":"20. House rules","text":"<p>By creating and using an account on SQA you confirm you have read and agree to follow our House Rules.</p>"},{"location":"terms_of_use/#21-third-party-software","title":"21. Third Party Software","text":"<p>Our software, website and/or services may include software components supplied by third parties which are utilized by permission of the respective licensors and/or copyright holders on the terms provided by such parties (\"Third Party Software\"). SQA expressly disclaims any warranty or other assurance to you regarding Third Party Software. Please note that your use of the Third Party Software will be governed by the terms and conditions of use and privacy policies of the Third Party Software providers and not by these Terms of Use or our Privacy Policy.</p>"},{"location":"terms_of_use/#22-scripts","title":"22. Scripts","text":"<p>You represent and warrant that you have all intellectual property rights, including all necessary patent, trademark, trade secret, copyright or other proprietary rights, in and to your script. If you use third-party materials, you represent and warrant that you have the right to distribute third-party material in the script. You agree that you will not submit material that is copyrighted, protected by trade secret or otherwise subject to third party proprietary rights, including patent, privacy and publicity rights, unless you are the owner of such rights or have permission from their rightful owner to submit the material.</p> <p>You are solely responsible for any script that you create. SQA is not in any way responsible for the use or misuse of your script by any user. SQA is not in any way responsible for the use or misuse of any user\u2019s script by you.</p> <p>By using the publish script feature, you grant us a world-wide, irrevocable, perpetual, royalty-free license to:</p> <ul> <li>publish this script as well as the username of the author;</li> <li>disclose the source code of the script for open scripts;</li> <li>perform, display, use and make available your open or protected script for any user or an invite-only script for any user that received an invite.</li> </ul> <p>We may remove your script without notice if we reasonably believe that you are in violation of these Terms of Use.</p> <p>You can publish the script under any license. If you do not include the license in the comment section of a script, you agree that your script is licensed under the Mozilla Public License 2.0.</p>"},{"location":"terms_of_use/#23-publications-no-recommendation-or-advice-status","title":"23. Publications - No Recommendation or Advice Status","text":"<p>The information and publications are not meant to be, and do not constitute, financial, investment, trading, or other types of advice or recommendations supplied or endorsed by SQA.</p> <p>Any statement of view (which may be subject to change without notice) is the author's personal opinion, and the author makes no representations or warranties as to the accuracy or completeness of any information or analysis provided.</p> <p>The authors and SQA are not liable for any losses incurred as a result of any investment made on the basis of any perceived recommendation, forecast, or other information presented here.</p> <p>The contents of these publications should not be interpreted as an express or implicit promise, guarantee, or indication by SQA that customers will profit or that losses in connection with them can or will be limited if they rely on the information provided.</p> <p>SQA may update these Terms of Use at any time</p>"},{"location":"advanced/","title":"Advanced Features","text":"<p>Explore SQA's advanced capabilities for professional-grade analysis.</p>"},{"location":"advanced/#power-tools-for-serious-analysis","title":"Power Tools for Serious Analysis","text":"<p>SQA goes beyond basic technical analysis with powerful features for portfolio management, strategy optimization, and real-time trading.</p>"},{"location":"advanced/#available-features","title":"Available Features","text":""},{"location":"advanced/#portfolio-management","title":"Portfolio Management","text":"<p>Track positions, calculate P&amp;L, manage commissions, and monitor portfolio performance.</p> <p>Key Capabilities: - Position tracking with share quantities - Commission and fee calculations - Realized and unrealized P&amp;L - Portfolio value over time</p> <p>Learn more \u2192</p>"},{"location":"advanced/#backtesting-framework","title":"Backtesting Framework","text":"<p>Simulate trading strategies on historical data with comprehensive performance metrics.</p> <p>Performance Metrics: - Total return and annualized return - Sharpe ratio and Sortino ratio - Maximum drawdown - Win rate and profit factor</p> <p>Learn more \u2192</p>"},{"location":"advanced/#strategy-generator","title":"Strategy Generator","text":"<p>Reverse-engineer profitable trades to discover patterns and generate new strategies.</p> <p>Workflow: 1. Identify profitable entry/exit points 2. Capture indicator states at those points 3. Mine patterns from indicator combinations 4. Generate executable strategies</p> <p>Learn more \u2192</p>"},{"location":"advanced/#genetic-programming","title":"Genetic Programming","text":"<p>Evolve optimal strategy parameters using genetic algorithms.</p> <p>Process: - Define parameter space (genes) - Create random population - Evaluate fitness via backtesting - Evolve through selection, crossover, mutation</p> <p>Learn more \u2192</p>"},{"location":"advanced/#real-time-streaming","title":"Real-Time Streaming","text":"<p>Process live price data with event callbacks and parallel strategy execution.</p> <p>Features: - Rolling window of recent data - On-the-fly indicator calculations - Multiple strategies in parallel - Customizable callbacks</p> <p>Learn more \u2192</p>"},{"location":"advanced/#fpop-analysis","title":"FPOP Analysis","text":"<p>Future Period of Performance analysis for risk/reward calculations.</p> <p>Capabilities: - Calculate future returns - Direction classification - Risk/reward metrics - Performance attribution</p> <p>Learn more \u2192</p>"},{"location":"advanced/#example-workflow","title":"Example Workflow","text":"<pre><code>graph LR\n    A[Historical Data] --&gt; B[Strategy Generator]\n    B --&gt; C[Discovered Patterns]\n    C --&gt; D[Generated Strategies]\n    D --&gt; E[Genetic Programming]\n    E --&gt; F[Optimized Parameters]\n    F --&gt; G[Backtest]\n    G --&gt; H{Results Good?}\n    H --&gt;|Yes| I[Live Stream]\n    H --&gt;|No| D\n    I --&gt; J[Portfolio Management]</code></pre>"},{"location":"advanced/#use-cases","title":"Use Cases","text":""},{"location":"advanced/#quantitative-research","title":"Quantitative Research","text":"<ul> <li>Pattern discovery in historical data</li> <li>Parameter optimization</li> <li>Strategy validation</li> </ul>"},{"location":"advanced/#algorithmic-trading-educational","title":"Algorithmic Trading (Educational)","text":"<ul> <li>Real-time signal generation</li> <li>Portfolio tracking</li> <li>Performance monitoring</li> </ul>"},{"location":"advanced/#risk-management","title":"Risk Management","text":"<ul> <li>Drawdown analysis</li> <li>Volatility tracking</li> <li>Position sizing</li> </ul> <p>Remember: These are powerful tools for education and research. Always test thoroughly before considering any real trading applications.</p>"},{"location":"advanced/backtesting/","title":"Backtesting Framework","text":""},{"location":"advanced/backtesting/#overview","title":"Overview","text":"<p>Simulate trading strategies on historical data to evaluate performance before risking real capital.</p>"},{"location":"advanced/backtesting/#quick-start","title":"Quick Start","text":"<pre><code>require 'sqa'\n\n# Load stock data\nstock = SQA::Stock.new(ticker: 'AAPL')\n\n# Create backtest\nbacktest = SQA::Backtest.new(\n  stock: stock,\n  strategy: SQA::Strategy::RSI,\n  initial_cash: 10_000,\n  commission: 1.0\n)\n\n# Run simulation\nresults = backtest.run\n\n# View results\nputs \"Total Return: #{results.total_return}%\"\nputs \"Sharpe Ratio: #{results.sharpe_ratio}\"\nputs \"Max Drawdown: #{results.max_drawdown}%\"\nputs \"Win Rate: #{results.win_rate}%\"\n</code></pre>"},{"location":"advanced/backtesting/#configuration","title":"Configuration","text":""},{"location":"advanced/backtesting/#basic-parameters","title":"Basic Parameters","text":"<pre><code>backtest = SQA::Backtest.new(\n  stock: stock,                    # SQA::Stock object\n  strategy: SQA::Strategy::MACD,   # Strategy class\n  initial_cash: 10_000,            # Starting capital\n  commission: 1.0,                 # Per-trade commission\n  position_size: 100               # Shares per trade\n)\n</code></pre>"},{"location":"advanced/backtesting/#results-object","title":"Results Object","text":"<p>The <code>backtest.run</code> method returns a results object with:</p>"},{"location":"advanced/backtesting/#return-metrics","title":"Return Metrics","text":"<ul> <li><code>total_return</code> - Total percentage return</li> <li><code>annualized_return</code> - Return per year</li> <li><code>benchmark_return</code> - Buy-and-hold comparison</li> </ul>"},{"location":"advanced/backtesting/#risk-metrics","title":"Risk Metrics","text":"<ul> <li><code>sharpe_ratio</code> - Risk-adjusted return</li> <li><code>sortino_ratio</code> - Downside risk-adjusted return</li> <li><code>max_drawdown</code> - Largest peak-to-trough decline</li> <li><code>volatility</code> - Standard deviation of returns</li> </ul>"},{"location":"advanced/backtesting/#trading-metrics","title":"Trading Metrics","text":"<ul> <li><code>num_trades</code> - Total number of trades</li> <li><code>win_rate</code> - Percentage of profitable trades</li> <li><code>avg_win</code> - Average winning trade</li> <li><code>avg_loss</code> - Average losing trade</li> <li><code>profit_factor</code> - Gross profit / gross loss</li> </ul>"},{"location":"advanced/backtesting/#portfolio-metrics","title":"Portfolio Metrics","text":"<ul> <li><code>final_value</code> - Ending portfolio value</li> <li><code>portfolio_value</code> - Value over time (array)</li> <li><code>trades</code> - Full trade history</li> </ul>"},{"location":"advanced/backtesting/#complete-example","title":"Complete Example","text":"<pre><code># Load data\nstock = SQA::Stock.new(ticker: 'AAPL')\n\n# Test multiple strategies\nstrategies = [\n  SQA::Strategy::RSI,\n  SQA::Strategy::MACD,\n  SQA::Strategy::BollingerBands\n]\n\nstrategies.each do |strategy|\n  backtest = SQA::Backtest.new(\n    stock: stock,\n    strategy: strategy,\n    initial_cash: 10_000\n  )\n\n  results = backtest.run\n\n  puts \"\\n#{strategy.name} Results:\"\n  puts \"-\" * 40\n  puts \"Return: #{results.total_return.round(2)}%\"\n  puts \"Sharpe: #{results.sharpe_ratio.round(2)}\"\n  puts \"Max DD: #{results.max_drawdown.round(2)}%\"\n  puts \"Trades: #{results.num_trades}\"\n  puts \"Win Rate: #{results.win_rate.round(2)}%\"\nend\n</code></pre>"},{"location":"advanced/backtesting/#advanced-usage","title":"Advanced Usage","text":""},{"location":"advanced/backtesting/#custom-date-range","title":"Custom Date Range","text":"<pre><code># Backtest specific period\nstock = SQA::Stock.new(\n  ticker: 'AAPL',\n  start_date: '2020-01-01',\n  end_date: '2023-12-31'\n)\n\nbacktest = SQA::Backtest.new(stock: stock, strategy: strategy)\nresults = backtest.run\n</code></pre>"},{"location":"advanced/backtesting/#parameter-optimization","title":"Parameter Optimization","text":"<pre><code># Test different RSI thresholds\n(20..40).step(5).each do |oversold|\n  results = test_strategy_with_params(oversold)\n  puts \"RSI #{oversold}: Return = #{results.total_return}%\"\nend\n</code></pre>"},{"location":"advanced/backtesting/#walk-forward-testing","title":"Walk-Forward Testing","text":"<pre><code># Train on first 70%, test on last 30%\ntrain_end = (stock.df.height * 0.7).to_i\ntrain_stock = stock.df[0...train_end]\ntest_stock = stock.df[train_end..-1]\n\n# Optimize on training data\nbest_params = optimize_on(train_stock)\n\n# Validate on test data\nresults = backtest_with_params(test_stock, best_params)\n</code></pre>"},{"location":"advanced/backtesting/#visualization","title":"Visualization","text":"<pre><code># Plot equity curve\nrequire 'gruff'\n\ng = Gruff::Line.new\ng.title = \"Portfolio Value Over Time\"\ng.data(\"Portfolio\", results.portfolio_value)\ng.write('equity_curve.png')\n</code></pre>"},{"location":"advanced/backtesting/#best-practices","title":"Best Practices","text":""},{"location":"advanced/backtesting/#1-use-enough-data","title":"1. Use Enough Data","text":"<ul> <li>Minimum: 252 trading days (1 year)</li> <li>Recommended: 1260+ days (5 years)</li> <li>Include different market conditions</li> </ul>"},{"location":"advanced/backtesting/#2-account-for-costs","title":"2. Account for Costs","text":"<pre><code>backtest = SQA::Backtest.new(\n  commission: 1.0,        # Per trade\n  slippage: 0.001         # 0.1% slippage\n)\n</code></pre>"},{"location":"advanced/backtesting/#3-avoid-overfitting","title":"3. Avoid Overfitting","text":"<ul> <li>Use walk-forward analysis</li> <li>Test on out-of-sample data</li> <li>Limit parameter optimization</li> </ul>"},{"location":"advanced/backtesting/#4-compare-to-benchmark","title":"4. Compare to Benchmark","text":"<pre><code>if results.total_return &lt; results.benchmark_return\n  puts \"\u26a0\ufe0f  Strategy underperforms buy-and-hold\"\nend\n</code></pre>"},{"location":"advanced/backtesting/#5-check-multiple-metrics","title":"5. Check Multiple Metrics","text":"<p>Don't rely on return alone: - Sharpe ratio (risk-adjusted) - Max drawdown (worst case) - Win rate (consistency) - Profit factor (quality)</p>"},{"location":"advanced/backtesting/#common-pitfalls","title":"Common Pitfalls","text":"<p>\u274c Survivorship Bias: Only testing stocks that still exist \u274c Look-Ahead Bias: Using future data \u274c Curve Fitting: Over-optimizing parameters \u274c Ignoring Costs: Unrealistic commission/slippage \u274c Small Sample: Too few trades for statistical significance  </p>"},{"location":"advanced/backtesting/#related","title":"Related","text":"<ul> <li>Portfolio Management - Track positions and P&amp;L</li> <li>Strategy Generator - Discover patterns</li> <li>Risk Management - Position sizing and risk metrics</li> </ul>"},{"location":"advanced/ensemble/","title":"Ensemble Strategies","text":"<p>Combine multiple strategies with voting and meta-learning.</p>"},{"location":"advanced/ensemble/#basic-ensemble","title":"Basic Ensemble","text":"<pre><code>ensemble = SQA::Ensemble.new(\n  strategies: [\n    SQA::Strategy::RSI,\n    SQA::Strategy::MACD,\n    SQA::Strategy::BollingerBands\n  ],\n  voting_method: :majority\n)\n\nsignal = ensemble.signal(vector)  # =&gt; :buy, :sell, or :hold\n</code></pre>"},{"location":"advanced/ensemble/#voting-methods","title":"Voting Methods","text":""},{"location":"advanced/ensemble/#majority-voting","title":"Majority Voting","text":"<pre><code>voting_method: :majority  # Most common signal wins\n</code></pre>"},{"location":"advanced/ensemble/#weighted-voting","title":"Weighted Voting","text":"<pre><code>voting_method: :weighted\n# Weight strategies by past performance\n</code></pre>"},{"location":"advanced/ensemble/#unanimous","title":"Unanimous","text":"<pre><code>voting_method: :unanimous  # All must agree\n</code></pre>"},{"location":"advanced/ensemble/#confidence-based","title":"Confidence-Based","text":"<pre><code>voting_method: :confidence  # Weight by confidence scores\n</code></pre>"},{"location":"advanced/ensemble/#dynamic-weighting","title":"Dynamic Weighting","text":"<pre><code># Update weights based on performance\nensemble.update_weight(SQA::Strategy::RSI, 1.5)   # Increase weight\nensemble.update_weight(SQA::Strategy::MACD, 0.5)  # Decrease weight\n</code></pre>"},{"location":"advanced/ensemble/#strategy-rotation","title":"Strategy Rotation","text":"<pre><code># Select best strategy for current market\nselected = ensemble.rotate(stock)\n# Automatically switches based on recent performance\n</code></pre>"},{"location":"advanced/ensemble/#backtest-comparison","title":"Backtest Comparison","text":"<pre><code>comparison = ensemble.backtest_comparison(stock)\n\ncomparison.each do |name, results|\n  puts \"#{name}: Return = #{results[:return]}%\"\nend\n</code></pre>"},{"location":"advanced/fpop/","title":"FPOP - Future Period of Performance","text":""},{"location":"advanced/fpop/#overview","title":"Overview","text":"<p>Calculate future returns, risk metrics, and direction classification to evaluate trading opportunities.</p>"},{"location":"advanced/fpop/#quick-start","title":"Quick Start","text":"<pre><code>require 'sqa'\n\nstock = SQA::Stock.new(ticker: 'AAPL')\nprices = stock.df[\"adj_close_price\"].to_a\n\n# Calculate FPL (Future Period Loss/Profit)\nfpl_data = SQA::FPOP.fpl(prices, fpop: 10)\n# =&gt; [[min_delta, max_delta], ...]\n\n# Comprehensive analysis\nanalysis = SQA::FPOP.fpl_analysis(prices, fpop: 10)\nputs \"Risk: #{analysis[:risk]}%\"\nputs \"Direction: #{analysis[:direction]}\"  # :UP, :DOWN, :FLAT\n</code></pre>"},{"location":"advanced/fpop/#methods","title":"Methods","text":""},{"location":"advanced/fpop/#basic-fpl-calculation","title":"Basic FPL Calculation","text":"<pre><code>prices = [100, 102, 105, 103, 107, 110]\nfpl = SQA::FPOP.fpl(prices, fpop: 3)\n\n# For each point, calculates min/max change over next 3 periods\n# fpl[0] = [min(102,105,103) - 100, max(102,105,103) - 100]\n#        = [100-100, 105-100] = [0, 5]\n</code></pre>"},{"location":"advanced/fpop/#comprehensive-analysis","title":"Comprehensive Analysis","text":"<pre><code>analysis = SQA::FPOP.fpl_analysis(prices, fpop: 10)\n\n# Returns hash with:\n# {\n#   fpl: [[min_delta, max_delta], ...],\n#   risk: 15.5,              # Max downside %\n#   reward: 25.2,            # Max upside %\n#   direction: :UP,          # Overall trend\n#   magnitude: 10.3,         # Average move size\n#   quality_score: 0.75      # Risk/reward ratio\n# }\n</code></pre>"},{"location":"advanced/fpop/#quality-filtering","title":"Quality Filtering","text":"<pre><code>filtered = SQA::FPOP.filter_by_quality(\n  analysis,\n  min_magnitude: 5.0,      # Minimum 5% move\n  max_risk: 25.0,          # Maximum 25% downside\n  directions: [:UP]         # Only upward moves\n)\n\n# Returns only high-quality opportunities\n</code></pre>"},{"location":"advanced/fpop/#integration-with-strategy-generator","title":"Integration with Strategy Generator","text":"<pre><code>generator = SQA::StrategyGenerator.new(\n  stock: stock,\n  min_gain_percent: 10.0,\n  fpop: 10,                  # Use 10-period lookahead\n  max_fpl_risk: 20.0         # Filter by max acceptable risk\n)\n\npatterns = generator.discover_patterns\n# Only includes patterns with acceptable risk/reward\n</code></pre>"},{"location":"advanced/fpop/#dataframe-methods","title":"DataFrame Methods","text":"<pre><code># Convenient DataFrame extensions\ndf = stock.df\n\n# Add FPL columns\ndf_with_fpl = df.fpl(fpop: 10)\n\n# Add full analysis\ndf_with_analysis = df.fpl_analysis(fpop: 10)\n\n# Now has columns: fpl_min, fpl_max, fpl_risk, fpl_direction, etc.\n</code></pre>"},{"location":"advanced/fpop/#use-cases","title":"Use Cases","text":""},{"location":"advanced/fpop/#1-opportunity-screening","title":"1. Opportunity Screening","text":"<pre><code>stocks = ['AAPL', 'GOOGL', 'MSFT']\n\nstocks.each do |ticker|\n  stock = SQA::Stock.new(ticker: ticker)\n  prices = stock.df[\"adj_close_price\"].to_a\n\n  analysis = SQA::FPOP.fpl_analysis(prices, fpop: 10)\n\n  if analysis[:reward] &gt; 15.0 &amp;&amp; analysis[:risk] &lt; 10.0\n    puts \"#{ticker}: Good risk/reward (#{analysis[:reward]}/#{analysis[:risk]})\"\n  end\nend\n</code></pre>"},{"location":"advanced/fpop/#2-entry-point-validation","title":"2. Entry Point Validation","text":"<pre><code># Check if current point offers good risk/reward\ncurrent_analysis = SQA::FPOP.fpl_analysis(prices, fpop: 10)\n\nif current_analysis[:direction] == :UP &amp;&amp; \n   current_analysis[:quality_score] &gt; 0.7\n  puts \"Strong buy opportunity\"\nend\n</code></pre>"},{"location":"advanced/fpop/#3-stop-loss-calculation","title":"3. Stop Loss Calculation","text":"<pre><code>analysis = SQA::FPOP.fpl_analysis(prices, fpop: 10)\n\n# Set stop loss based on expected risk\nentry_price = prices.last\nstop_loss = entry_price * (1 - analysis[:risk] / 100)\n\nputs \"Entry: $#{entry_price}\"\nputs \"Stop Loss: $#{stop_loss}\"\nputs \"Target: $#{entry_price * (1 + analysis[:reward] / 100)}\"\n</code></pre>"},{"location":"advanced/fpop/#parameters","title":"Parameters","text":"<ul> <li><code>fpop</code>: Future periods to analyze (default: 10)</li> <li><code>min_magnitude</code>: Minimum move size to consider (%)</li> <li><code>max_risk</code>: Maximum acceptable downside (%)</li> <li><code>directions</code>: Filter by <code>:UP</code>, <code>:DOWN</code>, or <code>:FLAT</code></li> </ul>"},{"location":"advanced/fpop/#related","title":"Related","text":"<ul> <li>Strategy Generator - Uses FPOP for pattern quality</li> <li>Risk Management - Position sizing based on risk</li> <li>Backtesting - Validate FPOP predictions</li> </ul>"},{"location":"advanced/multi-timeframe/","title":"Multi-Timeframe Analysis","text":"<p>Analyze multiple timeframes simultaneously for better trade timing.</p>"},{"location":"advanced/multi-timeframe/#setup","title":"Setup","text":"<pre><code>mta = SQA::MultiTimeframe.new(stock: stock)\n</code></pre>"},{"location":"advanced/multi-timeframe/#trend-alignment","title":"Trend Alignment","text":"<pre><code>alignment = mta.trend_alignment\n\n# {\n#   daily: :up,\n#   weekly: :up,\n#   monthly: :up,\n#   aligned: true,\n#   direction: :bullish\n# }\n\nif alignment[:aligned] &amp;&amp; alignment[:direction] == :bullish\n  puts \"Strong uptrend across all timeframes\"\nend\n</code></pre>"},{"location":"advanced/multi-timeframe/#multi-timeframe-signal","title":"Multi-Timeframe Signal","text":"<pre><code># Higher timeframe = trend, lower timeframe = timing\nsignal = mta.signal(\n  strategy_class: SQA::Strategy::RSI,\n  higher_timeframe: :weekly,   # Trend filter\n  lower_timeframe: :daily      # Entry timing\n)\n\n# Only takes trades aligned with higher timeframe trend\n</code></pre>"},{"location":"advanced/multi-timeframe/#supportresistance","title":"Support/Resistance","text":"<pre><code># Find levels that appear across multiple timeframes\nlevels = mta.support_resistance(tolerance: 0.02)\n\nlevels.each do |level|\n  puts \"Strong level at #{level[:price]}\"\n  puts \"  Appears in: #{level[:timeframes].join(', ')}\"\nend\n</code></pre>"},{"location":"advanced/multi-timeframe/#divergence-detection","title":"Divergence Detection","text":"<pre><code># Price makes new high but indicator doesn't (bearish)\ndivergence = mta.detect_divergence(\n  indicator: :rsi,\n  lookback: 20\n)\n\nif divergence[:type] == :bearish\n  puts \"Bearish divergence detected - potential reversal\"\nend\n</code></pre>"},{"location":"advanced/pattern-matcher/","title":"Pattern Matcher","text":"<p>Pattern recognition and similarity search for forecasting.</p>"},{"location":"advanced/pattern-matcher/#find-similar-patterns","title":"Find Similar Patterns","text":"<pre><code>matcher = SQA::PatternMatcher.new(stock: stock)\n\n# Find historical patterns similar to current\nsimilar = matcher.find_similar(\n  lookback: 10,           # 10-period pattern\n  num_matches: 5,          # Find 5 best matches\n  method: :euclidean      # Distance metric\n)\n\nsimilar.each do |match|\n  puts \"Distance: #{match[:distance]}\"\n  puts \"Future return: #{match[:future_return]}%\"\nend\n</code></pre>"},{"location":"advanced/pattern-matcher/#distance-methods","title":"Distance Methods","text":"<ul> <li><code>:euclidean</code> - Standard distance</li> <li><code>:dtw</code> - Dynamic Time Warping (handles compression/stretching)</li> <li><code>:correlation</code> - Correlation-based similarity</li> </ul>"},{"location":"advanced/pattern-matcher/#forecasting","title":"Forecasting","text":"<pre><code>forecast = matcher.forecast(\n  lookback: 10,\n  forecast_periods: 5,\n  method: :dtw\n)\n\nputs \"Forecast price: #{forecast[:forecast_price]}\"\nputs \"Expected return: #{forecast[:forecast_return]}%\"\nputs \"95% CI: #{forecast[:confidence_interval_95]}\"\n</code></pre>"},{"location":"advanced/pattern-matcher/#chart-pattern-detection","title":"Chart Pattern Detection","text":"<pre><code># Detect double top/bottom\npatterns = matcher.detect_chart_pattern(:double_top)\n\n# Detect head &amp; shoulders\npatterns = matcher.detect_chart_pattern(:head_and_shoulders)\n\n# Detect triangles\npatterns = matcher.detect_chart_pattern(:triangle)\n\npatterns.each do |pattern|\n  puts \"#{pattern[:type]} at index #{pattern[:index]}\"\n  puts \"Confidence: #{pattern[:confidence]}\"\nend\n</code></pre>"},{"location":"advanced/pattern-matcher/#pattern-clustering","title":"Pattern Clustering","text":"<pre><code># Group similar patterns\nclusters = matcher.cluster_patterns(\n  num_clusters: 5,\n  lookback: 10\n)\n\nclusters.each_with_index do |cluster, i|\n  puts \"Cluster #{i}: #{cluster.size} patterns\"\n  puts \"  Avg future return: #{cluster[:avg_return]}%\"\nend\n</code></pre>"},{"location":"advanced/portfolio-optimizer/","title":"Portfolio Optimizer","text":"<p>Multi-objective portfolio optimization for optimal asset allocation and rebalancing.</p>"},{"location":"advanced/portfolio-optimizer/#maximum-sharpe-portfolio","title":"Maximum Sharpe Portfolio","text":"<pre><code># Get returns for multiple stocks\nreturns_matrix = ['AAPL', 'GOOGL', 'MSFT'].map do |ticker|\n  stock = SQA::Stock.new(ticker: ticker)\n  prices = stock.df[\"adj_close_price\"].to_a\n  prices.each_cons(2).map { |a, b| (b - a) / a }\nend\n\n# Find optimal weights\nresult = SQA::PortfolioOptimizer.maximum_sharpe(returns_matrix)\n\nputs \"Optimal Weights:\"\nputs \"  AAPL: #{(result[:weights][0] * 100).round(2)}%\"\nputs \"  GOOGL: #{(result[:weights][1] * 100).round(2)}%\"\nputs \"  MSFT: #{(result[:weights][2] * 100).round(2)}%\"\nputs \"\\nExpected Sharpe: #{result[:sharpe].round(2)}\"\n</code></pre>"},{"location":"advanced/portfolio-optimizer/#minimum-variance-portfolio","title":"Minimum Variance Portfolio","text":"<pre><code>result = SQA::PortfolioOptimizer.minimum_variance(returns_matrix)\n# Lowest risk allocation\n</code></pre>"},{"location":"advanced/portfolio-optimizer/#risk-parity","title":"Risk Parity","text":"<pre><code>result = SQA::PortfolioOptimizer.risk_parity(returns_matrix)\n# Equal risk contribution from each asset\n</code></pre>"},{"location":"advanced/portfolio-optimizer/#efficient-frontier","title":"Efficient Frontier","text":"<pre><code>frontier = SQA::PortfolioOptimizer.efficient_frontier(\n  returns_matrix,\n  num_portfolios: 50\n)\n\nfrontier.each do |portfolio|\n  puts \"Return: #{portfolio[:return]}, Risk: #{portfolio[:volatility]}\"\nend\n</code></pre>"},{"location":"advanced/portfolio-optimizer/#multi-objective-optimization","title":"Multi-Objective Optimization","text":"<pre><code>result = SQA::PortfolioOptimizer.multi_objective(\n  returns_matrix,\n  objectives: {\n    maximize_return: 0.4,\n    minimize_volatility: 0.3,\n    minimize_drawdown: 0.3\n  }\n)\n</code></pre>"},{"location":"advanced/portfolio-optimizer/#rebalancing","title":"Rebalancing","text":"<pre><code>current_weights = [0.5, 0.3, 0.2]\ntarget_weights = [0.4, 0.4, 0.2]\n\ntrades = SQA::PortfolioOptimizer.rebalance(\n  current_weights: current_weights,\n  target_weights: target_weights,\n  portfolio_value: 10_000\n)\n\n# trades =&gt; [{ ticker: 'AAPL', shares: -5, value: -750 }, ...]\n</code></pre>"},{"location":"advanced/portfolio/","title":"Portfolio Management","text":""},{"location":"advanced/portfolio/#overview","title":"Overview","text":"<p>The Portfolio class tracks positions, calculates P&amp;L, manages commissions, and monitors portfolio performance over time.</p>"},{"location":"advanced/portfolio/#creating-a-portfolio","title":"Creating a Portfolio","text":"<pre><code>require 'sqa'\n\nportfolio = SQA::Portfolio.new(\n  initial_cash: 10_000,    # Starting capital\n  commission: 1.0           # Commission per trade\n)\n</code></pre>"},{"location":"advanced/portfolio/#basic-operations","title":"Basic Operations","text":""},{"location":"advanced/portfolio/#buy-stock","title":"Buy Stock","text":"<pre><code>portfolio.buy('AAPL', shares: 10, price: 150.0)\n# Deducts: (10 \u00d7 $150) + $1 commission = $1,501\n\nputs portfolio.cash  # =&gt; 8,499.0\nputs portfolio.positions['AAPL']  # =&gt; 10 shares\n</code></pre>"},{"location":"advanced/portfolio/#sell-stock","title":"Sell Stock","text":"<pre><code>portfolio.sell('AAPL', shares: 5, price: 160.0)\n# Adds: (5 \u00d7 $160) - $1 commission = $799\n\nputs portfolio.cash  # =&gt; 9,298.0\nputs portfolio.positions['AAPL']  # =&gt; 5 shares\n</code></pre>"},{"location":"advanced/portfolio/#calculate-portfolio-value","title":"Calculate Portfolio Value","text":"<pre><code>current_prices = {\n  'AAPL' =&gt; 165.0,\n  'GOOGL' =&gt; 2800.0\n}\n\ntotal_value = portfolio.value(current_prices)\n# Cash + (positions \u00d7 current prices)\n</code></pre>"},{"location":"advanced/portfolio/#complete-example","title":"Complete Example","text":"<pre><code># Initialize\nportfolio = SQA::Portfolio.new(initial_cash: 10_000)\n\n# Buy multiple stocks\nportfolio.buy('AAPL', shares: 10, price: 150.0)\nportfolio.buy('GOOGL', shares: 2, price: 2750.0)\n\n# Check positions\nputs \"Positions: #{portfolio.positions}\"\n# =&gt; {\"AAPL\"=&gt;10, \"GOOGL\"=&gt;2}\n\n# Calculate current value\nprices = { 'AAPL' =&gt; 160.0, 'GOOGL' =&gt; 2800.0 }\nputs \"Portfolio Value: $#{portfolio.value(prices)}\"\n\n# Sell some shares\nportfolio.sell('AAPL', shares: 5, price: 160.0)\n\n# View trade history\nportfolio.trades.each do |trade|\n  puts \"#{trade.action} #{trade.shares} #{trade.ticker} @ $#{trade.price}\"\nend\n</code></pre>"},{"location":"advanced/portfolio/#pl-tracking","title":"P&amp;L Tracking","text":""},{"location":"advanced/portfolio/#realized-pl","title":"Realized P&amp;L","text":"<p>Profit/loss from closed positions (sold shares).</p> <pre><code># Buy 10 shares @ $150\nportfolio.buy('AAPL', shares: 10, price: 150.0)\n\n# Sell 5 shares @ $160\nportfolio.sell('AAPL', shares: 5, price: 160.0)\n\n# Realized P&amp;L: (160 - 150) \u00d7 5 = $50\n# (minus 2 \u00d7 $1 commission = $48)\n</code></pre>"},{"location":"advanced/portfolio/#unrealized-pl","title":"Unrealized P&amp;L","text":"<p>Paper profit/loss on open positions.</p> <pre><code># Still holding 5 shares bought @ $150\n# Current price: $165\n\nunrealized_pnl = (165.0 - 150.0) * 5  # =&gt; $75\n</code></pre>"},{"location":"advanced/portfolio/#portfolio-methods","title":"Portfolio Methods","text":"Method Description <code>buy(ticker, shares:, price:)</code> Purchase shares <code>sell(ticker, shares:, price:)</code> Sell shares <code>value(current_prices)</code> Calculate total portfolio value <code>positions</code> Hash of ticker \u2192 share count <code>trades</code> Array of all trades <code>cash</code> Available cash balance"},{"location":"advanced/portfolio/#usage-with-backtesting","title":"Usage with Backtesting","text":"<pre><code>backtest = SQA::Backtest.new(\n  stock: stock,\n  strategy: SQA::Strategy::RSI,\n  initial_cash: 10_000,\n  commission: 1.0\n)\n\nresults = backtest.run\n\nputs \"Final Value: $#{results.portfolio_value}\"\nputs \"Total Return: #{results.total_return}%\"\nputs \"Total Trades: #{results.num_trades}\"\n</code></pre>"},{"location":"advanced/portfolio/#advanced-features","title":"Advanced Features","text":""},{"location":"advanced/portfolio/#position-sizing","title":"Position Sizing","text":"<pre><code># Risk-based position sizing\nrisk_per_trade = portfolio.cash * 0.02  # 2% risk\nshares = (risk_per_trade / stop_loss_distance).to_i\n\nportfolio.buy('AAPL', shares: shares, price: current_price)\n</code></pre>"},{"location":"advanced/portfolio/#diversification-check","title":"Diversification Check","text":"<pre><code>def check_diversification(portfolio, prices)\n  total_value = portfolio.value(prices)\n\n  portfolio.positions.each do |ticker, shares|\n    position_value = shares * prices[ticker]\n    percentage = (position_value / total_value) * 100\n\n    puts \"#{ticker}: #{percentage.round(2)}%\"\n    warn \"\u26a0\ufe0f  #{ticker} exceeds 20%\" if percentage &gt; 20\n  end\nend\n</code></pre>"},{"location":"advanced/portfolio/#related","title":"Related","text":"<ul> <li>Backtesting - Test strategies with portfolio tracking</li> <li>Risk Management - Position sizing and risk metrics</li> <li>Portfolio Optimizer - Optimal asset allocation</li> </ul>"},{"location":"advanced/risk-management/","title":"Risk Management","text":""},{"location":"advanced/risk-management/#overview","title":"Overview","text":"<p>Comprehensive risk management tools including VaR, position sizing, and risk metrics.</p>"},{"location":"advanced/risk-management/#value-at-risk-var","title":"Value at Risk (VaR)","text":"<p>Calculate potential losses at specified confidence level:</p> <pre><code>require 'sqa'\n\nprices = stock.df[\"adj_close_price\"].to_a\nreturns = prices.each_cons(2).map { |a, b| (b - a) / a }\n\n# 95% confidence VaR\nvar_95 = SQA::RiskManager.var(returns, confidence: 0.95, method: :historical)\nputs \"VaR (95%): #{(var_95 * 100).round(2)}%\"\n\n# Conditional VaR (Expected Shortfall)\ncvar_95 = SQA::RiskManager.cvar(returns, confidence: 0.95)\nputs \"CVaR (95%): #{(cvar_95 * 100).round(2)}%\"\n</code></pre>"},{"location":"advanced/risk-management/#position-sizing","title":"Position Sizing","text":""},{"location":"advanced/risk-management/#kelly-criterion","title":"Kelly Criterion","text":"<pre><code># Optimal position size based on win rate and payoffs\nposition = SQA::RiskManager.kelly_criterion(\n  win_rate: 0.60,        # 60% win rate\n  avg_win: 0.10,         # Average 10% gain\n  avg_loss: 0.05,        # Average 5% loss\n  capital: 10_000\n)\n\nputs \"Kelly Position: $#{position}\"\n</code></pre>"},{"location":"advanced/risk-management/#fixed-fractional","title":"Fixed Fractional","text":"<pre><code># Risk fixed % of capital per trade\nposition = SQA::RiskManager.fixed_fractional(\n  capital: 10_000,\n  risk_percent: 0.02,    # Risk 2% per trade\n  stop_loss_percent: 0.05 # 5% stop loss\n)\n\nshares = (position / current_price).to_i\n</code></pre>"},{"location":"advanced/risk-management/#percent-volatility","title":"Percent Volatility","text":"<pre><code># Size based on volatility\nposition = SQA::RiskManager.percent_volatility(\n  capital: 10_000,\n  target_volatility: 0.02,  # 2% target vol\n  price_volatility: 0.25     # Stock's 25% annualized vol\n)\n</code></pre>"},{"location":"advanced/risk-management/#risk-metrics","title":"Risk Metrics","text":""},{"location":"advanced/risk-management/#sharpe-ratio","title":"Sharpe Ratio","text":"<pre><code>sharpe = SQA::RiskManager.sharpe_ratio(returns, risk_free_rate: 0.02)\nputs \"Sharpe Ratio: #{sharpe.round(2)}\"\n\n# &gt; 1.0 = Good\n# &gt; 2.0 = Very Good\n# &gt; 3.0 = Excellent\n</code></pre>"},{"location":"advanced/risk-management/#sortino-ratio","title":"Sortino Ratio","text":"<pre><code># Like Sharpe but only penalizes downside volatility\nsortino = SQA::RiskManager.sortino_ratio(returns, risk_free_rate: 0.02)\nputs \"Sortino Ratio: #{sortino.round(2)}\"\n</code></pre>"},{"location":"advanced/risk-management/#calmar-ratio","title":"Calmar Ratio","text":"<pre><code># Annual return / Maximum drawdown\nprices = stock.df[\"adj_close_price\"].to_a\ncalmar = SQA::RiskManager.calmar_ratio(prices)\nputs \"Calmar Ratio: #{calmar.round(2)}\"\n</code></pre>"},{"location":"advanced/risk-management/#maximum-drawdown","title":"Maximum Drawdown","text":"<pre><code>max_dd = SQA::RiskManager.max_drawdown(prices)\nputs \"Max Drawdown: #{(max_dd * 100).round(2)}%\"\n</code></pre>"},{"location":"advanced/risk-management/#monte-carlo-simulation","title":"Monte Carlo Simulation","text":"<pre><code># Simulate potential outcomes\nsimulations = SQA::RiskManager.monte_carlo_simulation(\n  returns: returns,\n  initial_value: 10_000,\n  periods: 252,          # 1 year\n  num_simulations: 1000\n)\n\n# Analyze results\noutcomes = simulations.map(&amp;:last).sort\npercentile_5 = outcomes[(outcomes.size * 0.05).to_i]\npercentile_95 = outcomes[(outcomes.size * 0.95).to_i]\n\nputs \"5th percentile: $#{percentile_5.round(2)}\"\nputs \"95th percentile: $#{percentile_95.round(2)}\"\n</code></pre>"},{"location":"advanced/risk-management/#complete-example","title":"Complete Example","text":"<pre><code># Comprehensive risk assessment\nclass RiskAssessment\n  def initialize(stock)\n    @stock = stock\n    @prices = stock.df[\"adj_close_price\"].to_a\n    @returns = calculate_returns\n  end\n\n  def assess\n    {\n      var_95: SQA::RiskManager.var(@returns, confidence: 0.95),\n      cvar_95: SQA::RiskManager.cvar(@returns, confidence: 0.95),\n      sharpe: SQA::RiskManager.sharpe_ratio(@returns),\n      sortino: SQA::RiskManager.sortino_ratio(@returns),\n      max_dd: SQA::RiskManager.max_drawdown(@prices),\n      volatility: @returns.standard_deviation\n    }\n  end\n\n  def position_size(capital, method: :kelly)\n    case method\n    when :kelly\n      SQA::RiskManager.kelly_criterion(\n        win_rate: calculate_win_rate,\n        avg_win: calculate_avg_win,\n        avg_loss: calculate_avg_loss,\n        capital: capital\n      )\n    when :fixed\n      SQA::RiskManager.fixed_fractional(\n        capital: capital,\n        risk_percent: 0.02,\n        stop_loss_percent: 0.05\n      )\n    end\n  end\n\n  private\n\n  def calculate_returns\n    @prices.each_cons(2).map { |a, b| (b - a) / a }\n  end\n\n  def calculate_win_rate\n    wins = @returns.count { |r| r &gt; 0 }\n    wins.to_f / @returns.size\n  end\n\n  def calculate_avg_win\n    wins = @returns.select { |r| r &gt; 0 }\n    wins.sum / wins.size\n  end\n\n  def calculate_avg_loss\n    losses = @returns.select { |r| r &lt; 0 }\n    losses.sum.abs / losses.size\n  end\nend\n\n# Usage\nassessment = RiskAssessment.new(stock)\nmetrics = assessment.assess\nposition = assessment.position_size(10_000, method: :kelly)\n\nputs \"Risk Metrics:\"\nputs \"  VaR (95%): #{(metrics[:var_95] * 100).round(2)}%\"\nputs \"  Sharpe: #{metrics[:sharpe].round(2)}\"\nputs \"  Max DD: #{(metrics[:max_dd] * 100).round(2)}%\"\nputs \"\\nRecommended Position: $#{position.round(2)}\"\n</code></pre>"},{"location":"advanced/risk-management/#best-practices","title":"Best Practices","text":"<ol> <li>Diversify: Don't risk more than 2-5% per trade</li> <li>Use Stop Losses: Always define maximum acceptable loss</li> <li>Monitor Correlations: Avoid correlated positions</li> <li>Regular Reassessment: Update risk metrics monthly</li> <li>Stress Testing: Run Monte Carlo simulations</li> </ol>"},{"location":"advanced/risk-management/#related","title":"Related","text":"<ul> <li>Portfolio Optimizer - Optimal allocation</li> <li>FPOP - Risk/reward analysis</li> <li>Backtesting - Test risk management rules</li> </ul>"},{"location":"advanced/strategy-generator/","title":"Strategy Generator","text":""},{"location":"advanced/strategy-generator/#overview","title":"Overview","text":"<p>Reverse-engineer profitable trades to discover patterns and automatically generate executable trading strategies.</p>"},{"location":"advanced/strategy-generator/#how-it-works","title":"How It Works","text":"<ol> <li>Identify Profitable Points: Scan historical data for entry points that led to profitable exits</li> <li>Capture Indicator States: Record all indicator values at those profitable points</li> <li>Mine Patterns: Find common combinations of indicator states</li> <li>Generate Strategies: Create executable strategy code from patterns</li> </ol>"},{"location":"advanced/strategy-generator/#quick-start","title":"Quick Start","text":"<pre><code>require 'sqa'\n\n# Load stock data\nstock = SQA::Stock.new(ticker: 'AAPL')\n\n# Create generator\ngenerator = SQA::StrategyGenerator.new(\n  stock: stock,\n  min_gain_percent: 10.0,  # Minimum 10% profit\n  fpop: 10                  # Look ahead 10 periods\n)\n\n# Discover patterns\npatterns = generator.discover_patterns\n\n# Generate strategy from first pattern\nstrategy_code = generator.generate_strategy(pattern_index: 0)\nputs strategy_code\n</code></pre>"},{"location":"advanced/strategy-generator/#configuration","title":"Configuration","text":"<pre><code>generator = SQA::StrategyGenerator.new(\n  stock: stock,\n  min_gain_percent: 10.0,      # Minimum profit required\n  max_loss_percent: -5.0,       # Maximum acceptable loss\n  fpop: 10,                     # Future periods to analyze\n  min_support: 3                # Minimum pattern occurrences\n)\n</code></pre>"},{"location":"advanced/strategy-generator/#discovering-patterns","title":"Discovering Patterns","text":"<pre><code>patterns = generator.discover_patterns\n\npatterns.each_with_index do |pattern, i|\n  puts \"\\nPattern #{i}:\"\n  puts \"  Support: #{pattern[:support]} occurrences\"\n  puts \"  Avg Gain: #{pattern[:avg_gain].round(2)}%\"\n  puts \"  Win Rate: #{pattern[:win_rate].round(2)}%\"\n\n  puts \"  Conditions:\"\n  pattern[:conditions].each do |cond|\n    puts \"    - #{cond[:indicator]}: #{cond[:state]}\"\n  end\nend\n</code></pre>"},{"location":"advanced/strategy-generator/#generating-strategy-code","title":"Generating Strategy Code","text":"<pre><code>strategy_code = generator.generate_strategy(\n  pattern_index: 0,\n  class_name: 'DiscoveredStrategy'\n)\n\n# Save to file\nFile.write('lib/sqa/strategy/discovered_strategy.rb', strategy_code)\n\n# Load and use\nrequire_relative 'lib/sqa/strategy/discovered_strategy'\nsignal = SQA::Strategy::DiscoveredStrategy.trade(vector)\n</code></pre>"},{"location":"advanced/strategy-generator/#context-aware-patterns","title":"Context-Aware Patterns","text":"<pre><code># Include market context in pattern discovery\npatterns = generator.discover_context_aware_patterns(\n  analyze_regime: true,     # Include bull/bear/sideways\n  analyze_seasonal: true,   # Include month/quarter\n  sector: :technology       # Sector classification\n)\n\n# Patterns include context\npattern = patterns.first\nputs \"Valid in: #{pattern.context.valid_months}\"      # =&gt; [10, 11, 12]\nputs \"Valid regimes: #{pattern.context.valid_regimes}\" # =&gt; [:bull]\nputs \"Sector: #{pattern.context.sector}\"               # =&gt; :technology\n</code></pre>"},{"location":"advanced/strategy-generator/#walk-forward-validation","title":"Walk-Forward Validation","text":"<pre><code># Prevent overfitting with out-of-sample testing\nvalidated_patterns = generator.walk_forward_validate(\n  train_size: 250,  # Training period (days)\n  test_size: 60     # Testing period (days)\n)\n\nvalidated_patterns.each do |result|\n  puts \"Pattern #{result[:pattern_index]}:\"\n  puts \"  Train Return: #{result[:train_return]}%\"\n  puts \"  Test Return: #{result[:test_return]}%\"\n  puts \"  Robust: #{result[:robust]}\"  # true if test performance acceptable\nend\n</code></pre>"},{"location":"advanced/strategy-generator/#example-output","title":"Example Output","text":"<pre><code># Generated strategy example\nclass SQA::Strategy::Pattern_1\n  def self.trade(vector)\n    return :hold unless valid_data?(vector)\n\n    # Pattern: Oversold RSI + Bullish MACD + High Volume\n    if vector.rsi[:trend] == :over_sold &amp;&amp;\n       vector.macd[:crossover] == :bullish &amp;&amp;\n       vector.volume_ratio &gt; 1.5\n      :buy\n    else\n      :hold\n    end\n  end\n\n  private\n\n  def self.valid_data?(vector)\n    vector.respond_to?(:rsi) &amp;&amp;\n    vector.respond_to?(:macd) &amp;&amp;\n    vector.respond_to?(:volume_ratio)\n  end\nend\n</code></pre>"},{"location":"advanced/strategy-generator/#best-practices","title":"Best Practices","text":"<ol> <li>Use Sufficient Data: At least 1-2 years of historical data</li> <li>Validate Patterns: Use walk-forward testing</li> <li>Filter by Support: Require minimum pattern occurrences (3-5)</li> <li>Consider Context: Include market regime and seasonality</li> <li>Backtest Generated Strategies: Always test before using live</li> </ol>"},{"location":"advanced/strategy-generator/#related","title":"Related","text":"<ul> <li>Genetic Programming - Optimize strategy parameters</li> <li>KBS Strategy - Rule-based strategies</li> <li>Backtesting - Test discovered strategies</li> </ul>"},{"location":"advanced/streaming/","title":"Real-Time Streaming","text":""},{"location":"advanced/streaming/#overview","title":"Overview","text":"<p>Process live price data with event callbacks and parallel strategy execution for real-time trading signals.</p>"},{"location":"advanced/streaming/#quick-start","title":"Quick Start","text":"<pre><code>require 'sqa'\n\n# Create stream\nstream = SQA::Stream.new(\n  ticker: 'AAPL',\n  strategies: [SQA::Strategy::RSI, SQA::Strategy::MACD],\n  window_size: 50\n)\n\n# Register callback\nstream.on_signal do |signal, data|\n  puts \"#{Time.now}: Signal = #{signal}\"\n  puts \"Price: #{data[:price]}\"\n  puts \"Volume: #{data[:volume]}\"\n\n  # Execute trade, send alert, log data, etc.\n  execute_trade(signal, data) if signal != :hold\nend\n\n# Start receiving updates\nstream.update(price: 150.25, volume: 1_000_000)\nstream.update(price: 150.50, volume: 1_200_000)\n</code></pre>"},{"location":"advanced/streaming/#features","title":"Features","text":""},{"location":"advanced/streaming/#rolling-window","title":"Rolling Window","text":"<p>Maintains recent price/volume history:</p> <pre><code>stream = SQA::Stream.new(\n  ticker: 'AAPL',\n  window_size: 50  # Keep last 50 data points\n)\n\n# Automatically manages memory\n1000.times do |i|\n  stream.update(price: 100 + rand, volume: 1000000)\n  # Only keeps most recent 50 points\nend\n</code></pre>"},{"location":"advanced/streaming/#on-the-fly-indicators","title":"On-the-Fly Indicators","text":"<p>Calculates indicators from rolling window:</p> <pre><code>stream.update(price: 150.0, volume: 1_000_000)\n\n# Indicators calculated automatically\n# - RSI from last 14 prices\n# - MACD from price history\n# - SMA/EMA from rolling window\n</code></pre>"},{"location":"advanced/streaming/#parallel-strategy-execution","title":"Parallel Strategy Execution","text":"<p>Runs multiple strategies simultaneously:</p> <pre><code>stream = SQA::Stream.new(\n  ticker: 'AAPL',\n  strategies: [\n    SQA::Strategy::RSI,\n    SQA::Strategy::MACD,\n    SQA::Strategy::BollingerBands\n  ]\n)\n\n# All strategies execute on each update\nstream.update(price: 150.0, volume: 1_000_000)\n# Each strategy generates independent signal\n</code></pre>"},{"location":"advanced/streaming/#signal-aggregation","title":"Signal Aggregation","text":"<p>Combine multiple strategy signals:</p> <pre><code>stream.on_signal do |signals, data|\n  # signals = {\n  #   RSI: :buy,\n  #   MACD: :hold,\n  #   BollingerBands: :buy\n  # }\n\n  # Count votes\n  buy_votes = signals.values.count(:buy)\n  sell_votes = signals.values.count(:sell)\n\n  # Consensus decision\n  if buy_votes &gt;= 2\n    execute_buy(data[:price])\n  elsif sell_votes &gt;= 2\n    execute_sell(data[:price])\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#complete-example","title":"Complete Example","text":"<pre><code># Initialize stream\nstream = SQA::Stream.new(\n  ticker: 'AAPL',\n  strategies: [\n    SQA::Strategy::RSI,\n    SQA::Strategy::MACD\n  ],\n  window_size: 100\n)\n\n# Track performance\ntrades = []\n\n# Register callbacks\nstream.on_signal do |signals, data|\n  consensus = calculate_consensus(signals)\n\n  if consensus == :buy\n    trades &lt;&lt; {\n      action: :buy,\n      price: data[:price],\n      time: Time.now\n    }\n    send_alert(\"BUY signal at $#{data[:price]}\")\n  elsif consensus == :sell\n    trades &lt;&lt; {\n      action: :sell,\n      price: data[:price],\n      time: Time.now\n    }\n    send_alert(\"SELL signal at $#{data[:price]}\")\n  end\nend\n\n# Simulate live data feed\nloop do\n  # Get current price from API/feed\n  current_data = fetch_live_data('AAPL')\n\n  stream.update(\n    price: current_data[:price],\n    volume: current_data[:volume]\n  )\n\n  sleep 60  # Update every minute\nend\n</code></pre>"},{"location":"advanced/streaming/#integration-examples","title":"Integration Examples","text":""},{"location":"advanced/streaming/#with-websocket-feed","title":"With WebSocket Feed","text":"<pre><code>require 'faye/websocket'\nrequire 'eventmachine'\n\nEM.run do\n  ws = Faye::WebSocket::Client.new('wss://stream.example.com')\n\n  ws.on :message do |event|\n    data = JSON.parse(event.data)\n    stream.update(\n      price: data['price'],\n      volume: data['volume']\n    )\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#with-rest-api-polling","title":"With REST API Polling","text":"<pre><code>require 'faraday'\n\nloop do\n  response = Faraday.get(\"https://api.example.com/quote/AAPL\")\n  data = JSON.parse(response.body)\n\n  stream.update(\n    price: data['lastPrice'],\n    volume: data['volume']\n  )\n\n  sleep 10\nend\n</code></pre>"},{"location":"advanced/streaming/#best-practices","title":"Best Practices","text":"<ol> <li>Error Handling: Wrap callbacks in begin/rescue</li> <li>Performance: Limit callback complexity</li> <li>Memory: Use appropriate window_size</li> <li>Validation: Verify data before processing</li> <li>Logging: Track all signals and actions</li> </ol>"},{"location":"advanced/streaming/#related","title":"Related","text":"<ul> <li>Portfolio Management - Execute trades from signals</li> <li>Backtesting - Test strategies before going live</li> <li>Risk Management - Position sizing for live trading</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for SQA classes and modules.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":""},{"location":"api/#sqa-module","title":"SQA Module","text":"<p>Main module containing configuration and initialization.</p> <ul> <li><code>SQA.init</code> - Initialize SQA system</li> <li><code>SQA.config</code> - Access configuration</li> <li><code>SQA.data_dir</code> - Get data directory</li> <li><code>SQA.av</code> - Alpha Vantage API client</li> </ul>"},{"location":"api/#stock-class","title":"Stock Class","text":"<p>Represents a stock with historical data.</p> <pre><code>stock = SQA::Stock.new(ticker: 'AAPL')\n</code></pre> <p>Methods: - <code>#ticker</code> - Stock symbol - <code>#df</code> - DataFrame with price/volume data - <code>#update</code> - Fetch latest data - <code>#save_data</code> - Persist to disk</p>"},{"location":"api/#dataframe-class","title":"DataFrame Class","text":"<p>High-performance wrapper around Polars DataFrame.</p> <pre><code>df = stock.df\nprices = df[\"adj_close_price\"].to_a\n</code></pre> <p>Methods: - <code>#height</code> - Number of rows - <code>#column(name)</code> - Get column by name - <code>#head(n)</code> - First n rows - <code>#tail(n)</code> - Last n rows</p>"},{"location":"api/#strategy-classes","title":"Strategy Classes","text":"<p>Base class for all trading strategies.</p> <pre><code>signal = SQA::Strategy::RSI.trade(vector)\n</code></pre> <p>Common Interface: - <code>.trade(vector)</code> - Generate trading signal - <code>.trade_against(vector)</code> - Invert signal</p>"},{"location":"api/#advanced-classes","title":"Advanced Classes","text":""},{"location":"api/#portfolio-class","title":"Portfolio Class","text":"<p>Track positions and calculate P&amp;L.</p> <pre><code>portfolio = SQA::Portfolio.new(initial_cash: 10_000)\nportfolio.buy('AAPL', shares: 10, price: 150.0)\n</code></pre>"},{"location":"api/#backtest-class","title":"Backtest Class","text":"<p>Simulate strategies on historical data.</p> <pre><code>backtest = SQA::Backtest.new(stock: stock, strategy: SQA::Strategy::MACD)\nresults = backtest.run\n</code></pre>"},{"location":"api/#stream-class","title":"Stream Class","text":"<p>Process real-time price data.</p> <pre><code>stream = SQA::Stream.new(ticker: 'AAPL', strategies: [SQA::Strategy::RSI])\nstream.on_signal { |signal, data| puts \"Signal: #{signal}\" }\n</code></pre>"},{"location":"api/#indicator-functions-sqai","title":"Indicator Functions (SQAI)","text":"<p>All indicators from TA-Lib are available via the <code>SQAI</code> module.</p> <pre><code># Moving averages\nSQAI.sma(prices, period: 20)\nSQAI.ema(prices, period: 12)\n\n# Oscillators\nSQAI.rsi(prices, period: 14)\nSQAI.macd(prices, fast_period: 12, slow_period: 26, signal_period: 9)\n\n# Volatility\nSQAI.bbands(prices, period: 20, nbdev_up: 2, nbdev_down: 2)\nSQAI.atr(high, low, close, period: 14)\n</code></pre> <p>See the full indicator list.</p>"},{"location":"api/#configuration","title":"Configuration","text":""},{"location":"api/#config-class","title":"Config Class","text":"<p>Manage SQA configuration.</p> <pre><code>config = SQA::Config.new(data_dir: \"~/my_data\")\n</code></pre> <p>Properties: - <code>data_dir</code> - Data storage location - <code>log_level</code> - Logging verbosity - <code>debug</code> - Debug mode flag</p>"},{"location":"api/#error-classes","title":"Error Classes","text":"<ul> <li><code>SQA::ApiError</code> - API request failures</li> <li><code>SQA::BadParameterError</code> - Invalid parameters</li> <li><code>SQA::NoDataError</code> - Missing data</li> </ul> <p>For detailed documentation, see the source code or use Ruby's introspection:</p> <pre><code>SQA::Stock.instance_methods(false)\nSQAI.methods.grep(/^[a-z]/).sort\n</code></pre>"},{"location":"api/dataframe/","title":"DataFrame API Reference","text":""},{"location":"api/dataframe/#overview","title":"Overview","text":"<p><code>SQA::DataFrame</code> is a high-performance wrapper around the Polars DataFrame library, specifically optimized for time series financial data manipulation. Polars is a Rust-backed library that provides blazingly fast columnar data operations.</p> <p>The DataFrame system consists of two main components:</p> <ol> <li>SQA::DataFrame - The main wrapper class with financial data convenience methods</li> <li>SQA::DataFrame::Data - Metadata storage for stock information (separate from price data)</li> </ol>"},{"location":"api/dataframe/#architecture","title":"Architecture","text":""},{"location":"api/dataframe/#why-polars","title":"Why Polars?","text":"<p>Polars provides: - Blazing Speed: Rust-backed implementation with zero-copy operations - Memory Efficiency: Columnar storage format optimized for analytics - Lazy Evaluation: Query optimization before execution - Type Safety: Strong typing with automatic type inference</p>"},{"location":"api/dataframe/#wrapper-benefits","title":"Wrapper Benefits","text":"<p><code>SQA::DataFrame</code> wraps Polars to provide: - Financial data-specific convenience methods - Consistent column naming across data sources - FPL (Future Period Loss/Profit) analysis methods - Seamless integration with SQA workflows - Method delegation for full Polars API access</p>"},{"location":"api/dataframe/#class-sqadataframe","title":"Class: SQA::DataFrame","text":"<p>Location: <code>lib/sqa/data_frame.rb</code></p>"},{"location":"api/dataframe/#instance-attributes","title":"Instance Attributes","text":"<pre><code>df.data  # =&gt; Polars::DataFrame - The underlying Polars DataFrame\n</code></pre> <p>Direct access to the Polars DataFrame for advanced operations.</p>"},{"location":"api/dataframe/#class-methods","title":"Class Methods","text":""},{"location":"api/dataframe/#newraw_data-nil-mapping-transformers","title":"<code>.new(raw_data = nil, mapping: {}, transformers: {})</code>","text":"<p>Creates a new DataFrame instance with optional column mapping and transformations.</p> <p>Parameters: - <code>raw_data</code> (Hash, Array, Polars::DataFrame, nil) - Initial data - <code>mapping</code> (Hash) - Column name mappings <code>{ \"source_name\" =&gt; :target_name }</code> - <code>transformers</code> (Hash) - Value transformation lambdas <code>{ column: -&gt;(v) { transform(v) } }</code></p> <p>Returns: <code>SQA::DataFrame</code> instance</p> <p>Important: Columns are renamed FIRST, then transformers are applied. Transformers receive renamed column names.</p> <p>Example: <pre><code># From array of hashes\ndata = [\n  { 'Date' =&gt; '2024-01-01', 'Close' =&gt; '150.5' },\n  { 'Date' =&gt; '2024-01-02', 'Close' =&gt; '152.3' }\n]\n\nmapping = { 'Date' =&gt; :timestamp, 'Close' =&gt; :close_price }\ntransformers = { close_price: -&gt;(v) { v.to_f } }\n\ndf = SQA::DataFrame.new(data, mapping: mapping, transformers: transformers)\n</code></pre></p>"},{"location":"api/dataframe/#loadsource-transformers-mapping","title":"<code>.load(source:, transformers: {}, mapping: {})</code>","text":"<p>Loads a DataFrame from a CSV file with optional transformations.</p> <p>Parameters: - <code>source</code> (String, Pathname) - Path to CSV file - <code>mapping</code> (Hash) - Column name mappings (usually empty for cached data) - <code>transformers</code> (Hash) - Value transformations (usually empty for cached data)</p> <p>Returns: <code>SQA::DataFrame</code> instance</p> <p>Note: For cached CSV files, transformers and mapping should typically be empty since transformations were already applied when the data was first fetched.</p> <p>Example: <pre><code># Load from cached CSV (no transformations needed)\ndf = SQA::DataFrame.load(source: \"~/sqa_data/aapl.csv\")\n\n# Load with migration transformations\ndf = SQA::DataFrame.load(\n  source: \"old_data.csv\",\n  mapping: { 'date' =&gt; :timestamp },\n  transformers: { volume: -&gt;(v) { v.to_i } }\n)\n</code></pre></p>"},{"location":"api/dataframe/#from_csv_filesource-mapping-transformers","title":"<code>.from_csv_file(source, mapping: {}, transformers: {})</code>","text":"<p>Alias for <code>.load()</code> - loads DataFrame from CSV file.</p> <p>Example: <pre><code>df = SQA::DataFrame.from_csv_file('stock_data.csv')\n</code></pre></p>"},{"location":"api/dataframe/#from_json_filesource-mapping-transformers","title":"<code>.from_json_file(source, mapping: {}, transformers: {})</code>","text":"<p>Loads DataFrame from JSON file containing array of hashes.</p> <p>Parameters: - <code>source</code> (String, Pathname) - Path to JSON file - <code>mapping</code> (Hash) - Column name mappings - <code>transformers</code> (Hash) - Value transformations</p> <p>Returns: <code>SQA::DataFrame</code> instance</p> <p>Example: <pre><code># JSON format: [{\"date\": \"2024-01-01\", \"price\": 150.5}, ...]\ndf = SQA::DataFrame.from_json_file('prices.json')\n</code></pre></p>"},{"location":"api/dataframe/#from_aofhaofh-mapping-transformers","title":"<code>.from_aofh(aofh, mapping: {}, transformers: {})</code>","text":"<p>Creates DataFrame from Array of Hashes (AOFH).</p> <p>Parameters: - <code>aofh</code> (Array) - Array of hash records - <code>mapping</code> (Hash) - Column name mappings - <code>transformers</code> (Hash) - Value transformations <p>Returns: <code>SQA::DataFrame</code> instance</p> <p>Example: <pre><code>data = [\n  { date: '2024-01-01', price: 150.5, volume: 1000000 },\n  { date: '2024-01-02', price: 152.0, volume: 1100000 }\n]\n\ndf = SQA::DataFrame.from_aofh(data)\n</code></pre></p>"},{"location":"api/dataframe/#instance-methods","title":"Instance Methods","text":""},{"location":"api/dataframe/#column-operations","title":"Column Operations","text":""},{"location":"api/dataframe/#columns","title":"<code>#columns</code>","text":"<p>Returns array of column names.</p> <p>Returns: <code>Array&lt;String&gt;</code></p> <p>Example: <pre><code>df.columns\n# =&gt; [\"timestamp\", \"open_price\", \"high_price\", \"low_price\",\n#     \"close_price\", \"adj_close_price\", \"volume\"]\n</code></pre></p>"},{"location":"api/dataframe/#keys","title":"<code>#keys</code>","text":"<p>Alias for <code>#columns</code>.</p>"},{"location":"api/dataframe/#vectors","title":"<code>#vectors</code>","text":"<p>Alias for <code>#columns</code>.</p>"},{"location":"api/dataframe/#column_name","title":"<code>#[](column_name)</code>","text":"<p>Access column data (returns Polars::Series).</p> <p>Parameters: - <code>column_name</code> (String) - Name of column</p> <p>Returns: <code>Polars::Series</code></p> <p>Example: <pre><code># Get close prices\nclose_series = df[\"close_price\"]\n\n# Convert to array\nprices = df[\"close_price\"].to_a\n# =&gt; [150.5, 152.0, 151.5, ...]\n</code></pre></p>"},{"location":"api/dataframe/#rename_columnsmapping","title":"<code>#rename_columns!(mapping)</code>","text":"<p>Renames columns in place according to mapping.</p> <p>Parameters: - <code>mapping</code> (Hash) - Hash of old_name =&gt; new_name mappings</p> <p>Returns: <code>nil</code> (modifies in place)</p> <p>Important: - Normalizes symbol keys to strings - Tries exact match first, then lowercase match - Polars requires both keys and values to be strings</p> <p>Example: <pre><code>mapping = { 'Open' =&gt; :open_price, 'Close' =&gt; :close_price }\ndf.rename_columns!(mapping)\n</code></pre></p>"},{"location":"api/dataframe/#apply_transformerstransformers","title":"<code>#apply_transformers!(transformers)</code>","text":"<p>Applies transformation functions to columns in place.</p> <p>Parameters: - <code>transformers</code> (Hash) - Hash of column_name =&gt; lambda mappings</p> <p>Returns: <code>nil</code> (modifies in place)</p> <p>Example: <pre><code>transformers = {\n  volume: -&gt;(v) { v.to_i },\n  close_price: -&gt;(v) { v.to_f.round(2) }\n}\ndf.apply_transformers!(transformers)\n</code></pre></p>"},{"location":"api/dataframe/#dimension-methods","title":"Dimension Methods","text":""},{"location":"api/dataframe/#size","title":"<code>#size</code>","text":"<p>Returns number of rows.</p> <p>Returns: <code>Integer</code></p> <p>Aliases: <code>#nrows</code>, <code>#length</code></p> <p>Example: <pre><code>df.size      # =&gt; 250\ndf.nrows     # =&gt; 250\ndf.length    # =&gt; 250\n</code></pre></p>"},{"location":"api/dataframe/#ncols","title":"<code>#ncols</code>","text":"<p>Returns number of columns.</p> <p>Returns: <code>Integer</code></p> <p>Example: <pre><code>df.ncols  # =&gt; 7\n</code></pre></p>"},{"location":"api/dataframe/#data-combination","title":"Data Combination","text":""},{"location":"api/dataframe/#appendother_df","title":"<code>#append!(other_df)</code>","text":"<p>Appends another DataFrame's rows to this one.</p> <p>Parameters: - <code>other_df</code> (SQA::DataFrame) - DataFrame to append</p> <p>Returns: <code>nil</code> (modifies in place)</p> <p>Raises: <code>RuntimeError</code> if row count doesn't match expected</p> <p>Aliases: <code>#concat!</code></p> <p>Example: <pre><code># Combine two DataFrames\ndf1.append!(df2)\n\n# Verify\nputs df1.size  # =&gt; original size + df2 size\n</code></pre></p>"},{"location":"api/dataframe/#export-methods","title":"Export Methods","text":""},{"location":"api/dataframe/#to_csvpath_to_file","title":"<code>#to_csv(path_to_file)</code>","text":"<p>Writes DataFrame to CSV file.</p> <p>Parameters: - <code>path_to_file</code> (String, Pathname) - Destination file path</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>df.to_csv(\"~/sqa_data/aapl_backup.csv\")\n</code></pre></p>"},{"location":"api/dataframe/#to_h","title":"<code>#to_h</code>","text":"<p>Converts DataFrame to Hash with symbolized keys.</p> <p>Returns: <code>Hash</code> - Column name symbols to arrays</p> <p>Example: <pre><code>df.to_h\n# =&gt; {\n#   timestamp: [\"2024-01-01\", \"2024-01-02\", ...],\n#   close_price: [150.5, 152.0, ...],\n#   volume: [1000000, 1100000, ...]\n# }\n</code></pre></p>"},{"location":"api/dataframe/#fpl-analysis-methods","title":"FPL Analysis Methods","text":""},{"location":"api/dataframe/#fplcolumn-adj_close_price-fpop-14","title":"<code>#fpl(column: \"adj_close_price\", fpop: 14)</code>","text":"<p>Calculates Future Period Loss/Profit for each data point.</p> <p>Parameters: - <code>column</code> (String, Symbol) - Price column name - <code>fpop</code> (Integer) - Future Period of Performance (days to look ahead)</p> <p>Returns: <code>Array&lt;Array&lt;Float, Float&gt;&gt;</code> - Array of [min_delta, max_delta] pairs</p> <p>Example: <pre><code># Look 10 days into the future\nfpl_data = df.fpl(column: \"adj_close_price\", fpop: 10)\n# =&gt; [[-2.5, 5.3], [-1.2, 3.8], ...]\n</code></pre></p>"},{"location":"api/dataframe/#fpl_analysiscolumn-adj_close_price-fpop-14","title":"<code>#fpl_analysis(column: \"adj_close_price\", fpop: 14)</code>","text":"<p>Comprehensive FPL analysis with risk metrics and direction classification.</p> <p>Parameters: - <code>column</code> (String, Symbol) - Price column name - <code>fpop</code> (Integer) - Future Period of Performance</p> <p>Returns: <code>Array&lt;Hash&gt;</code> - Array of analysis hashes</p> <p>Hash Keys: - <code>:min_delta</code> - Minimum future price change % - <code>:max_delta</code> - Maximum future price change % - <code>:magnitude</code> - Average expected movement % - <code>:risk</code> - Volatility range - <code>:direction</code> - <code>:UP</code>, <code>:DOWN</code>, <code>:UNCERTAIN</code>, or <code>:FLAT</code></p> <p>Example: <pre><code>analysis = df.fpl_analysis(column: \"adj_close_price\", fpop: 10)\n\nanalysis.first\n# =&gt; {\n#   min_delta: -2.5,\n#   max_delta: 5.3,\n#   magnitude: 3.9,\n#   risk: 7.8,\n#   direction: :UP\n# }\n\n# Filter high-quality opportunities\nfiltered = SQA::FPOP.filter_by_quality(\n  analysis,\n  min_magnitude: 5.0,\n  max_risk: 25.0,\n  directions: [:UP]\n)\n</code></pre></p>"},{"location":"api/dataframe/#delegation-to-polars","title":"Delegation to Polars","text":"<p>Any method not defined on <code>SQA::DataFrame</code> is automatically delegated to the underlying <code>Polars::DataFrame</code>.</p> <p>Example: <pre><code># These call Polars methods directly\ndf.head(10)          # First 10 rows\ndf.tail(5)           # Last 5 rows\ndf.describe          # Statistical summary\ndf.filter(...)       # Polars filter expression\ndf.select(...)       # Select columns\ndf.with_column(...)  # Add computed column\n</code></pre></p> <p>See Polars documentation for full API.</p>"},{"location":"api/dataframe/#class-helper-methods","title":"Class Helper Methods","text":"<p>These utility methods are primarily used internally by data source adapters.</p>"},{"location":"api/dataframe/#generate_mappingkeys","title":"<code>.generate_mapping(keys)</code>","text":"<p>Generates column name mapping from source keys to underscored symbols.</p> <p>Parameters: - <code>keys</code> (Array) - Array of column names</p> <p>Returns: <code>Hash</code> - Mapping hash</p> <p>Example: <pre><code>keys = ['Open', 'High', 'Low', 'Close']\nmapping = SQA::DataFrame.generate_mapping(keys)\n# =&gt; { \"Open\" =&gt; :open, \"High\" =&gt; :high, \"Low\" =&gt; :low, \"Close\" =&gt; :close }\n</code></pre></p>"},{"location":"api/dataframe/#underscore_keykey","title":"<code>.underscore_key(key)</code>","text":"<p>Converts a key to underscored, lowercase symbol.</p> <p>Parameters: - <code>key</code> (String, Symbol) - Key to convert</p> <p>Returns: <code>Symbol</code></p> <p>Example: <pre><code>SQA::DataFrame.underscore_key('AdjClose')    # =&gt; :adj_close\nSQA::DataFrame.underscore_key('OpenPrice')   # =&gt; :open_price\n</code></pre></p> <p>Alias: <code>.sanitize_key</code></p>"},{"location":"api/dataframe/#normalize_keyshash-adapter_mapping","title":"<code>.normalize_keys(hash, adapter_mapping: {})</code>","text":"<p>Normalizes hash keys to underscored symbols.</p> <p>Parameters: - <code>hash</code> (Hash) - Hash to normalize - <code>adapter_mapping</code> (Hash) - Optional custom mappings</p> <p>Returns: <code>Hash</code> - Hash with normalized keys</p>"},{"location":"api/dataframe/#renamehash-mapping","title":"<code>.rename(hash, mapping)</code>","text":"<p>Renames hash keys according to mapping.</p> <p>Parameters: - <code>hash</code> (Hash) - Hash to modify - <code>mapping</code> (Hash) - Key mappings</p> <p>Returns: <code>Hash</code> - Modified hash</p>"},{"location":"api/dataframe/#is_datevalue","title":"<code>.is_date?(value)</code>","text":"<p>Checks if value looks like a date string (YYYY-MM-DD format).</p> <p>Parameters: - <code>value</code> (String) - Value to check</p> <p>Returns: <code>Boolean</code></p> <p>Example: <pre><code>SQA::DataFrame.is_date?(\"2024-01-01\")  # =&gt; true\nSQA::DataFrame.is_date?(\"150.5\")       # =&gt; false\n</code></pre></p>"},{"location":"api/dataframe/#class-sqadataframedata","title":"Class: SQA::DataFrame::Data","text":"<p>Location: <code>lib/sqa/data_frame/data.rb</code></p> <p>A metadata storage class for stock information, completely separate from the price/volume DataFrame.</p>"},{"location":"api/dataframe/#attributes","title":"Attributes","text":"<p>All attributes are read/write accessible via <code>attr_accessor</code>:</p> <ul> <li><code>ticker</code> (String) - Stock symbol (e.g., 'AAPL', 'MSFT')</li> <li><code>name</code> (String) - Company name</li> <li><code>exchange</code> (String) - Exchange symbol (NASDAQ, NYSE, etc.)</li> <li><code>source</code> (Symbol) - Data source (<code>:alpha_vantage</code>, <code>:yahoo_finance</code>)</li> <li><code>indicators</code> (Hash) - Technical indicators configuration</li> <li><code>overview</code> (Hash) - Company overview data from Alpha Vantage</li> </ul>"},{"location":"api/dataframe/#instance-methods_1","title":"Instance Methods","text":""},{"location":"api/dataframe/#newdata_hash-nil-ticker-nil-name-nil-exchange-nil-source-alpha_vantage-indicators-overview","title":"<code>.new(data_hash = nil, ticker: nil, name: nil, exchange: nil, source: :alpha_vantage, indicators: {}, overview: {})</code>","text":"<p>Dual initialization constructor supporting both hash and keyword arguments.</p> <p>From Hash (JSON deserialization): <pre><code>json_data = JSON.parse(File.read('aapl.json'))\ndata = SQA::DataFrame::Data.new(json_data)\n</code></pre></p> <p>From Keyword Arguments: <pre><code>data = SQA::DataFrame::Data.new(\n  ticker: 'AAPL',\n  source: :alpha_vantage,\n  indicators: { rsi: 14, sma: [20, 50] }\n)\n</code></pre></p>"},{"location":"api/dataframe/#to_jsonargs","title":"<code>#to_json(*args)</code>","text":"<p>Serializes metadata to JSON string.</p> <p>Returns: <code>String</code> - JSON representation</p> <p>Example: <pre><code>json_string = data.to_json\nFile.write('aapl.json', json_string)\n</code></pre></p>"},{"location":"api/dataframe/#to_h_1","title":"<code>#to_h</code>","text":"<p>Converts metadata to Hash.</p> <p>Returns: <code>Hash</code> - Hash representation</p> <p>Example: <pre><code>hash = data.to_h\n# =&gt; {\n#   ticker: 'AAPL',\n#   name: 'Apple Inc.',\n#   exchange: 'NASDAQ',\n#   source: :alpha_vantage,\n#   indicators: { rsi: 14 },\n#   overview: { ... }\n# }\n</code></pre></p>"},{"location":"api/dataframe/#usage-in-sqastock","title":"Usage in SQA::Stock","text":"<p><code>SQA::Stock</code> uses <code>DataFrame::Data</code> to persist metadata separately from price data:</p> <p>Persistence Pattern: <pre><code># In SQA::Stock\n@data_path = SQA.data_dir + \"#{@ticker}.json\"  # Metadata file\n@df_path = SQA.data_dir + \"#{@ticker}.csv\"     # Price data file\n\n# Save metadata\n@data_path.write(@data.to_json)\n\n# Load metadata\n@data = SQA::DataFrame::Data.new(JSON.parse(@data_path.read))\n</code></pre></p>"},{"location":"api/dataframe/#data-source-adapters","title":"Data Source Adapters","text":""},{"location":"api/dataframe/#alpha-vantage-adapter","title":"Alpha Vantage Adapter","text":"<p>Location: <code>lib/sqa/data_frame/alpha_vantage.rb</code></p> <p>Class: <code>SQA::DataFrame::AlphaVantage</code></p>"},{"location":"api/dataframe/#constants","title":"Constants","text":"<pre><code># Standard column headers\nHEADERS = [\n  :timestamp,       # 0\n  :open_price,      # 1\n  :high_price,      # 2\n  :low_price,       # 3\n  :close_price,     # 4\n  :adj_close_price, # 5\n  :volume           # 6\n]\n\n# Maps Alpha Vantage CSV columns to standard headers\nHEADER_MAPPING = {\n  \"timestamp\" =&gt; HEADERS[0],  # :timestamp\n  \"open\"      =&gt; HEADERS[1],  # :open_price\n  \"high\"      =&gt; HEADERS[2],  # :high_price\n  \"low\"       =&gt; HEADERS[3],  # :low_price\n  \"close\"     =&gt; HEADERS[4],  # :close_price\n  \"volume\"    =&gt; HEADERS[6]   # :volume\n}\n\n# Value transformations applied after renaming\nTRANSFORMERS = {\n  HEADERS[1] =&gt; -&gt;(v) { v.to_f.round(3) },  # :open_price\n  HEADERS[2] =&gt; -&gt;(v) { v.to_f.round(3) },  # :high_price\n  HEADERS[3] =&gt; -&gt;(v) { v.to_f.round(3) },  # :low_price\n  HEADERS[4] =&gt; -&gt;(v) { v.to_f.round(3) },  # :close_price\n  HEADERS[6] =&gt; -&gt;(v) { v.to_i }            # :volume\n}\n</code></pre>"},{"location":"api/dataframe/#recentticker-full-false-from_date-nil","title":"<code>.recent(ticker, full: false, from_date: nil)</code>","text":"<p>Fetches recent price data from Alpha Vantage API.</p> <p>Parameters: - <code>ticker</code> (String) - Stock symbol - <code>full</code> (Boolean) - If true, fetches full history; otherwise last 100 days - <code>from_date</code> (Date, String, nil) - Optional date filter</p> <p>Returns: <code>SQA::DataFrame</code> - Wrapped DataFrame with standardized columns</p> <p>Requirements: - Environment variable: <code>AV_API_KEY</code> or <code>ALPHAVANTAGE_API_KEY</code> - Free tier: 5 calls/minute, 500 calls/day</p> <p>Important: Alpha Vantage doesn't provide separate adjusted close, so <code>close_price</code> is duplicated as <code>adj_close_price</code> for compatibility.</p> <p>Example: <pre><code># Fetch recent 100 days\ndf = SQA::DataFrame::AlphaVantage.recent('AAPL')\n\n# Fetch full history\ndf = SQA::DataFrame::AlphaVantage.recent('AAPL', full: true)\n\n# Fetch from specific date\ndf = SQA::DataFrame::AlphaVantage.recent('AAPL', from_date: '2024-01-01')\n</code></pre></p>"},{"location":"api/dataframe/#yahoo-finance-adapter","title":"Yahoo Finance Adapter","text":"<p>Location: <code>lib/sqa/data_frame/yahoo_finance.rb</code></p> <p>Class: <code>SQA::DataFrame::YahooFinance</code></p>"},{"location":"api/dataframe/#constants_1","title":"Constants","text":"<pre><code>HEADERS = [\n  :timestamp,       # 0\n  :open_price,      # 1\n  :high_price,      # 2\n  :low_price,       # 3\n  :close_price,     # 4\n  :adj_close_price, # 5\n  :volume           # 6\n]\n\nHEADER_MAPPING = {\n  \"Date\"      =&gt; HEADERS[0],\n  \"Open\"      =&gt; HEADERS[1],\n  \"High\"      =&gt; HEADERS[2],\n  \"Low\"       =&gt; HEADERS[3],\n  \"Close\"     =&gt; HEADERS[4],\n  \"Adj Close\" =&gt; HEADERS[5],\n  \"Volume\"    =&gt; HEADERS[6]\n}\n</code></pre>"},{"location":"api/dataframe/#recentticker","title":"<code>.recent(ticker)</code>","text":"<p>Scrapes recent price data from Yahoo Finance website.</p> <p>Parameters: - <code>ticker</code> (String) - Stock symbol</p> <p>Returns: <code>SQA::DataFrame</code> - Wrapped DataFrame with standardized columns</p> <p>Note: Web scraping based, less reliable than API but requires no API key.</p> <p>Example: <pre><code>df = SQA::DataFrame::YahooFinance.recent('AAPL')\n</code></pre></p>"},{"location":"api/dataframe/#creating-custom-adapters","title":"Creating Custom Adapters","text":"<p>To add a new data source:</p> <ol> <li>Create <code>lib/sqa/data_frame/my_source.rb</code></li> <li>Define constants: <code>HEADERS</code>, <code>HEADER_MAPPING</code>, <code>TRANSFORMERS</code></li> <li>Implement <code>.recent(ticker, **options)</code> class method</li> <li>MUST return <code>SQA::DataFrame</code>, not raw Polars::DataFrame</li> </ol> <p>Example Template: <pre><code>class SQA::DataFrame::MySource\n  HEADERS = [\n    :timestamp,\n    :open_price,\n    :high_price,\n    :low_price,\n    :close_price,\n    :adj_close_price,\n    :volume\n  ]\n\n  HEADER_MAPPING = {\n    \"date\" =&gt; HEADERS[0],\n    \"open\" =&gt; HEADERS[1],\n    # ... map source columns to standard headers\n  }\n\n  TRANSFORMERS = {\n    HEADERS[1] =&gt; -&gt;(v) { v.to_f.round(3) },\n    HEADERS[6] =&gt; -&gt;(v) { v.to_i }\n  }\n\n  def self.recent(ticker, **options)\n    # 1. Fetch data from API/source\n    raw_data = fetch_from_source(ticker)\n\n    # 2. Convert to Polars DataFrame\n    polars_df = Polars.read_csv(StringIO.new(raw_data))\n\n    # 3. MUST wrap in SQA::DataFrame with mapping and transformers\n    sqa_df = SQA::DataFrame.new(\n      polars_df,\n      mapping: HEADER_MAPPING,\n      transformers: TRANSFORMERS\n    )\n\n    # 4. Add any missing columns if needed\n    # Example: Alpha Vantage doesn't have adj_close_price\n    # sqa_df.data = sqa_df.data.with_column(\n    #   sqa_df.data[\"close_price\"].alias(\"adj_close_price\")\n    # )\n\n    # 5. Return wrapped DataFrame\n    sqa_df\n  end\nend\n</code></pre></p>"},{"location":"api/dataframe/#usage-examples","title":"Usage Examples","text":""},{"location":"api/dataframe/#basic-workflow","title":"Basic Workflow","text":"<pre><code>require 'sqa'\n\nSQA.init\n\n# Load stock (fetches from Alpha Vantage by default)\nstock = SQA::Stock.new(ticker: 'AAPL')\n\n# Access DataFrame\ndf = stock.df\n\n# Get dimensions\nputs \"Rows: #{df.size}, Columns: #{df.ncols}\"\n# =&gt; Rows: 250, Columns: 7\n\n# Get column names\nputs df.columns.join(\", \")\n# =&gt; timestamp, open_price, high_price, low_price, close_price, adj_close_price, volume\n\n# Extract price array for indicators\nprices = df[\"adj_close_price\"].to_a\n\n# Calculate technical indicators (via sqa-tai gem)\nsma_20 = SQAI.sma(prices, period: 20)\nrsi_14 = SQAI.rsi(prices, period: 14)\n\nputs \"Current Price: #{prices.last}\"\nputs \"20-day SMA: #{sma_20.last}\"\nputs \"14-day RSI: #{rsi_14.last}\"\n</code></pre>"},{"location":"api/dataframe/#working-with-polars-directly","title":"Working with Polars Directly","text":"<pre><code># Access underlying Polars DataFrame\npolars_df = df.data\n\n# Filter using Polars expressions\nhigh_volume = polars_df.filter(\n  Polars.col(\"volume\") &gt; 10_000_000\n)\n\n# Calculate statistics\navg_close = polars_df[\"close_price\"].mean\nmax_high = polars_df[\"high_price\"].max\ntotal_volume = polars_df[\"volume\"].sum\n\n# Add computed columns\npolars_df = polars_df.with_column(\n  (Polars.col(\"close_price\") - Polars.col(\"open_price\"))\n    .alias(\"daily_change\")\n)\n</code></pre>"},{"location":"api/dataframe/#fpl-analysis-workflow","title":"FPL Analysis Workflow","text":"<pre><code># Get FPL analysis\nfpl_analysis = df.fpl_analysis(column: \"adj_close_price\", fpop: 10)\n\n# Find high-quality opportunities\nopportunities = SQA::FPOP.filter_by_quality(\n  fpl_analysis,\n  min_magnitude: 5.0,    # At least 5% expected move\n  max_risk: 25.0,        # Max 25% risk range\n  directions: [:UP]      # Only upward moves\n)\n\nputs \"Found #{opportunities.size} high-quality opportunities\"\n\nopportunities.each_with_index do |opp, idx|\n  puts \"\\nOpportunity ##{idx + 1}:\"\n  puts \"  Expected Move: #{opp[:magnitude].round(2)}%\"\n  puts \"  Risk: #{opp[:risk].round(2)}%\"\n  puts \"  Direction: #{opp[:direction]}\"\n  puts \"  Range: #{opp[:min_delta].round(2)}% to #{opp[:max_delta].round(2)}%\"\nend\n</code></pre>"},{"location":"api/dataframe/#data-export-and-import","title":"Data Export and Import","text":"<pre><code># Export to CSV\ndf.to_csv(\"aapl_prices.csv\")\n\n# Export to Hash\nhash = df.to_h\nFile.write(\"aapl_prices.json\", hash.to_json)\n\n# Load from CSV\ndf = SQA::DataFrame.load(source: \"aapl_prices.csv\")\n\n# Load from JSON\ndf = SQA::DataFrame.from_json_file(\"aapl_prices.json\")\n</code></pre>"},{"location":"api/dataframe/#combining-dataframes","title":"Combining DataFrames","text":"<pre><code># Load historical data\nhistorical_df = SQA::DataFrame.load(source: \"aapl_historical.csv\")\n\n# Fetch recent updates\nrecent_df = SQA::DataFrame::AlphaVantage.recent('AAPL')\n\n# Combine\nhistorical_df.append!(recent_df)\n\n# Save updated dataset\nhistorical_df.to_csv(\"aapl_updated.csv\")\n</code></pre>"},{"location":"api/dataframe/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/dataframe/#1-use-column-operations","title":"1. Use Column Operations","text":"<p>Good: <pre><code># Vectorized operation (fast)\navg = df.data[\"close_price\"].mean\n</code></pre></p> <p>Bad: <pre><code># Ruby loop (slow)\nprices = df[\"close_price\"].to_a\navg = prices.sum / prices.size.to_f\n</code></pre></p>"},{"location":"api/dataframe/#2-minimize-array-conversions","title":"2. Minimize Array Conversions","text":"<p>Only convert to arrays when necessary (e.g., passing to external functions):</p> <pre><code># Only convert for indicators\nprices = df[\"adj_close_price\"].to_a\nrsi = SQAI.rsi(prices, period: 14)\n\n# Use Polars for everything else\navg = df.data[\"adj_close_price\"].mean  # No conversion needed\n</code></pre>"},{"location":"api/dataframe/#3-batch-operations","title":"3. Batch Operations","text":"<p>Combine operations when possible:</p> <pre><code># Apply all transformations at once\ndf = SQA::DataFrame.new(\n  raw_data,\n  mapping: mapping,\n  transformers: transformers\n)\n\n# Instead of separate calls\ndf.rename_columns!(mapping)\ndf.apply_transformers!(transformers)\n</code></pre>"},{"location":"api/dataframe/#4-use-polars-native-operations","title":"4. Use Polars Native Operations","text":"<p>Leverage Polars' lazy evaluation and query optimization:</p> <pre><code># Polars can optimize this entire chain\nresult = df.data\n  .filter(Polars.col(\"volume\") &gt; 1_000_000)\n  .select([\"timestamp\", \"close_price\"])\n  .head(100)\n</code></pre>"},{"location":"api/dataframe/#5-avoid-repeated-column-access","title":"5. Avoid Repeated Column Access","text":"<p>Cache column data if used multiple times:</p> <pre><code># Good: cache the series\nclose_prices = df[\"close_price\"]\navg = close_prices.mean\nmax = close_prices.max\nmin = close_prices.min\n\n# Bad: repeated access\navg = df[\"close_price\"].mean\nmax = df[\"close_price\"].max\nmin = df[\"close_price\"].min\n</code></pre>"},{"location":"api/dataframe/#common-gotchas","title":"Common Gotchas","text":""},{"location":"api/dataframe/#1-dataframe-vs-polars","title":"1. DataFrame vs Polars","text":"<pre><code>df        # =&gt; SQA::DataFrame (wrapper)\ndf.data   # =&gt; Polars::DataFrame (underlying data)\n</code></pre> <p>Use <code>df.data</code> for direct Polars operations.</p>"},{"location":"api/dataframe/#2-column-names-are-strings","title":"2. Column Names are Strings","text":"<pre><code># Correct\ndf[\"close_price\"]\n\n# Wrong\ndf[:close_price]  # Polars uses strings, not symbols\n</code></pre>"},{"location":"api/dataframe/#3-transformers-expect-renamed-columns","title":"3. Transformers Expect Renamed Columns","text":"<p>Order matters in initialization: 1. Columns are renamed FIRST 2. Then transformers are applied</p> <p>Transformers receive the NEW column names, not the original names.</p> <pre><code>mapping = { 'Close' =&gt; :close_price }\ntransformers = { close_price: -&gt;(v) { v.to_f } }  # Use renamed name\n\ndf = SQA::DataFrame.new(data, mapping: mapping, transformers: transformers)\n</code></pre>"},{"location":"api/dataframe/#4-indicators-need-arrays","title":"4. Indicators Need Arrays","text":"<p>All SQAI/TAI indicator functions require Ruby arrays:</p> <pre><code># Correct\nprices = df[\"adj_close_price\"].to_a\nrsi = SQAI.rsi(prices, period: 14)\n\n# Wrong\nrsi = SQAI.rsi(df[\"adj_close_price\"], period: 14)  # Series not supported\n</code></pre>"},{"location":"api/dataframe/#5-method-delegation","title":"5. Method Delegation","text":"<p>Unknown methods are delegated to <code>Polars::DataFrame</code>:</p> <pre><code># These work via delegation\ndf.head(10)\ndf.describe\n\n# Check Polars docs for advanced features\n</code></pre>"},{"location":"api/dataframe/#6-csv-round-trip-considerations","title":"6. CSV Round-Trip Considerations","text":"<p>When loading cached CSV files, don't reapply transformers:</p> <pre><code># First time: apply transformers\ndf = SQA::DataFrame::AlphaVantage.recent('AAPL')\ndf.to_csv(\"aapl.csv\")\n\n# Later: don't reapply transformers (already applied)\ndf = SQA::DataFrame.load(source: \"aapl.csv\")\n# NOT: load(source: \"aapl.csv\", transformers: TRANSFORMERS)\n</code></pre>"},{"location":"api/dataframe/#7-data-source-return-types","title":"7. Data Source Return Types","text":"<p>All data source adapters MUST return <code>SQA::DataFrame</code>, not raw <code>Polars::DataFrame</code>:</p> <pre><code># Correct\ndef self.recent(ticker)\n  polars_df = fetch_data(ticker)\n  SQA::DataFrame.new(polars_df, mapping: MAPPING)  # Wrap it!\nend\n\n# Wrong\ndef self.recent(ticker)\n  fetch_data(ticker)  # Returns Polars::DataFrame\nend\n</code></pre>"},{"location":"api/dataframe/#recent-fixes-2024-11","title":"Recent Fixes (2024-11)","text":"<p>The DataFrame architecture underwent significant fixes to resolve type safety issues:</p>"},{"location":"api/dataframe/#issue-1-missing-dataframedata-class","title":"Issue 1: Missing DataFrame::Data Class","text":"<p>Problem: Stock metadata class didn't exist Fix: Created <code>SQA::DataFrame::Data</code> with dual initialization</p>"},{"location":"api/dataframe/#issue-2-type-mismatches","title":"Issue 2: Type Mismatches","text":"<p>Problem: Adapters returned <code>Polars::DataFrame</code> instead of <code>SQA::DataFrame</code> Fix: All adapters now wrap DataFrames before returning</p>"},{"location":"api/dataframe/#issue-3-missing-load-method","title":"Issue 3: Missing .load() Method","text":"<p>Problem: Stock tried to call non-existent <code>.load()</code> method Fix: Added class method with proper signature</p>"},{"location":"api/dataframe/#issue-4-column-mapping-order","title":"Issue 4: Column Mapping Order","text":"<p>Problem: Transformers applied before column renaming Fix: Renamed columns FIRST, then apply transformers</p>"},{"location":"api/dataframe/#issue-5-key-type-mismatches","title":"Issue 5: Key Type Mismatches","text":"<p>Problem: Symbol keys used where Polars expects strings Fix: Convert all keys to strings in <code>rename_columns!()</code></p>"},{"location":"api/dataframe/#issue-6-incorrect-polars-api-usage","title":"Issue 6: Incorrect Polars API Usage","text":"<p>Problem: Used <code>Polars::DataFrame.read_csv()</code> and <code>df[\"col\"].gt_eq()</code> Fix: Use <code>Polars.read_csv()</code> and <code>Polars.col(\"col\") &gt;=</code></p> <p>See <code>DATAFRAME_ARCHITECTURE_REVIEW.md</code> for detailed analysis.</p>"},{"location":"api/dataframe/#related-documentation","title":"Related Documentation","text":"<ul> <li>FPL Analysis - Future Period Loss/Profit utilities</li> <li>Technical Indicators - SQAI/TAI integration</li> <li>Polars Documentation - Underlying library</li> <li>Data Sources - Alpha Vantage and Yahoo Finance</li> </ul>"},{"location":"api/dataframe/#complete-example","title":"Complete Example","text":"<pre><code>require 'sqa'\n\n# Initialize\nSQA.init\n\n# Load stock data\nstock = SQA::Stock.new(ticker: 'AAPL')\ndf = stock.df\n\nputs \"=== Stock Information ===\"\nputs \"Ticker: #{stock.ticker}\"\nputs \"Exchange: #{stock.exchange}\"\nputs \"Source: #{stock.source}\"\nputs \"Data Points: #{df.size}\"\n\nputs \"\\n=== Price Data ===\"\nprices = df[\"adj_close_price\"].to_a\nputs \"Current Price: $#{prices.last.round(2)}\"\nputs \"52-Week High: $#{prices.max.round(2)}\"\nputs \"52-Week Low: $#{prices.min.round(2)}\"\n\nputs \"\\n=== Technical Indicators ===\"\nsma_20 = SQAI.sma(prices, period: 20)\nsma_50 = SQAI.sma(prices, period: 50)\nrsi_14 = SQAI.rsi(prices, period: 14)\n\nputs \"20-day SMA: $#{sma_20.last.round(2)}\"\nputs \"50-day SMA: $#{sma_50.last.round(2)}\"\nputs \"14-day RSI: #{rsi_14.last.round(2)}\"\n\nputs \"\\n=== FPL Analysis ===\"\nfpl_analysis = df.fpl_analysis(column: \"adj_close_price\", fpop: 10)\nlatest = fpl_analysis.last\n\nputs \"10-Day Forecast:\"\nputs \"  Direction: #{latest[:direction]}\"\nputs \"  Expected Move: #{latest[:magnitude].round(2)}%\"\nputs \"  Risk: #{latest[:risk].round(2)}%\"\nputs \"  Range: #{latest[:min_delta].round(2)}% to #{latest[:max_delta].round(2)}%\"\n\n# Export data\ndf.to_csv(\"aapl_export.csv\")\nFile.write(\"aapl_metadata.json\", stock.data.to_json)\n\nputs \"\\n=== Export Complete ===\"\nputs \"Data saved to aapl_export.csv\"\nputs \"Metadata saved to aapl_metadata.json\"\n</code></pre> <p>See Also: - Getting Started Guide - Examples Directory - Contributing Guide</p>"},{"location":"concepts/","title":"Core Concepts","text":"<p>Understanding the fundamental building blocks of SQA.</p>"},{"location":"concepts/#overview","title":"Overview","text":"<p>SQA is built around several key concepts that work together to provide a comprehensive stock analysis framework:</p> <ul> <li>Stock Objects - Represent individual stocks with historical data</li> <li>DataFrames - High-performance time series data structures</li> <li>Technical Indicators - Mathematical calculations on price/volume data</li> <li>Trading Strategies - Rules for generating buy/sell/hold signals</li> <li>Portfolio Management - Track positions and calculate P&amp;L</li> <li>Backtesting - Simulate strategies on historical data</li> </ul>"},{"location":"concepts/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TB\n    A[Data Source] --&gt;|Fetch| B[Stock Object]\n    B --&gt;|Contains| C[DataFrame]\n    C --&gt;|Calculate| D[Technical Indicators]\n    D --&gt;|Feed| E[Trading Strategies]\n    E --&gt;|Generate| F[Trading Signals]\n    F --&gt;|Execute| G[Portfolio]\n    G --&gt;|Track| H[Trades &amp; P/L]\n\n    E --&gt;|Test| I[Backtest]\n    I --&gt;|Evaluate| J[Performance Metrics]</code></pre>"},{"location":"concepts/#learn-more","title":"Learn More","text":"<ul> <li> <p> DataFrames</p> <p>High-performance data structures powered by Polars</p> <p> DataFrame Guide</p> </li> <li> <p> Indicators</p> <p>150+ technical analysis indicators via sqa-tai gem</p> <p> Indicators</p> </li> <li> <p> Strategies</p> <p>Framework for creating and executing trading strategies</p> <p> Strategies</p> </li> </ul>"},{"location":"contributing/","title":"Contributing to SQA","text":"<p>Thank you for your interest in contributing to SQA!</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<ul> <li>Report bugs</li> <li>Suggest features</li> <li>Improve documentation</li> <li>Submit pull requests</li> <li>Write tests</li> </ul>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes</li> <li>Run tests</li> <li>Submit a pull request</li> </ol>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<pre><code>git clone https://github.com/madbomber/sqa.git\ncd sqa\nbundle install\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nrake test\n\n# Run specific test file\nruby -Ilib:test test/strategy/rsi_test.rb\n\n# With coverage\nrake test\nopen coverage/index.html\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow Ruby community style guidelines</li> <li>Use meaningful variable names</li> <li>Add comments for complex logic</li> <li>Keep methods focused and small</li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Update documentation</li> <li>Add tests for new features</li> <li>Ensure all tests pass</li> <li>Update CHANGELOG.md</li> <li>Submit PR with clear description</li> </ol>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>Open an issue on GitHub or start a discussion.</p>"},{"location":"data-sources/","title":"Data Sources","text":"<p>SQA supports multiple data sources for historical stock price data.</p>"},{"location":"data-sources/#available-data-sources","title":"Available Data Sources","text":""},{"location":"data-sources/#alpha-vantage-primary","title":"Alpha Vantage (Primary)","text":"<p>Free API with generous limits for historical and real-time data.</p> <p>Setup: <pre><code>export AV_API_KEY=\"your_key_here\"\n</code></pre></p> <p>Features: - Daily historical data - Adjusted closing prices - Up to 20 years of history - API key required (free)</p> <p>Get API Key \u2192</p>"},{"location":"data-sources/#yahoo-finance-fallback","title":"Yahoo Finance (Fallback)","text":"<p>Web scraping fallback for when Alpha Vantage is unavailable.</p> <p>Features: - No API key required - Less reliable (web scraping) - Good for testing</p>"},{"location":"data-sources/#csv-files-custom","title":"CSV Files (Custom)","text":"<p>Import your own data from CSV files.</p> <p>Format: <pre><code>Date,Open,High,Low,Close,Adj Close,Volume\n2024-01-01,150.0,152.0,149.0,151.0,151.0,1000000\n</code></pre></p> <p>Place CSV files in <code>~/sqa_data/</code> named as <code>{ticker}.csv</code>.</p>"},{"location":"data-sources/#data-format","title":"Data Format","text":"<p>SQA uses a standardized column format:</p> <ul> <li><code>timestamp</code> - Date of trading day</li> <li><code>open_price</code> - Opening price</li> <li><code>high_price</code> - Highest price</li> <li><code>low_price</code> - Lowest price</li> <li><code>close_price</code> - Closing price</li> <li><code>adj_close_price</code> - Adjusted closing price</li> <li><code>volume</code> - Trading volume</li> </ul>"},{"location":"data-sources/#configuration","title":"Configuration","text":"<p>Set data directory in config:</p> <pre><code>SQA.config.data_dir = \"/path/to/data\"\n</code></pre> <p>Or via environment:</p> <pre><code>export SQA_DATA_DIR=\"/path/to/data\"\n</code></pre>"},{"location":"getting-started/","title":"Getting Started with SQA","text":"<p>Welcome to SQA! This guide will help you get up and running with stock market technical analysis in just a few minutes.</p>"},{"location":"getting-started/#what-youll-learn","title":"What You'll Learn","text":"<p>In this section, you'll learn how to:</p> <ul> <li>Install SQA and its dependencies</li> <li>Configure your environment for data access</li> <li>Run your first analysis</li> <li>Use the interactive console</li> <li>Understand the basic workflow</li> </ul>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>Ruby 3.2+ installed on your system</li> <li>TA-Lib C library (for technical indicators)</li> <li>(Optional) Alpha Vantage API key for live data access</li> </ul>"},{"location":"getting-started/#quick-navigation","title":"Quick Navigation","text":"<ul> <li> <p> Installation</p> <p>Install SQA and set up TA-Lib for technical analysis</p> <p> Installation Guide</p> </li> <li> <p> Quick Start</p> <p>Get your first analysis running in minutes</p> <p> Quick Start Guide</p> </li> </ul>"},{"location":"getting-started/#typical-workflow","title":"Typical Workflow","text":"<p>Here's the typical workflow when using SQA:</p> <pre><code>graph LR\n    A[Install SQA] --&gt; B[Configure API Keys]\n    B --&gt; C[Load Stock Data]\n    C --&gt; D[Calculate Indicators]\n    D --&gt; E[Apply Strategies]\n    E --&gt; F{Analysis Type}\n    F --&gt;|Backtest| G[Run Backtest]\n    F --&gt;|Live| H[Stream Real-Time]\n    F --&gt;|Research| I[Explore in Console]\n    G --&gt; J[Review Results]\n    H --&gt; J\n    I --&gt; J</code></pre>"},{"location":"getting-started/#whats-next","title":"What's Next?","text":"<p>Once you've completed the getting started guides, you can explore:</p> <ul> <li>Core Concepts - Deep dive into SQA's architecture</li> <li>Technical Indicators - Learn about the 150+ indicators</li> <li>Trading Strategies - Explore built-in and custom strategies</li> <li>Advanced Features - Portfolio management, backtesting, and more</li> </ul>"},{"location":"getting-started/#need-help","title":"Need Help?","text":"<p>If you run into issues:</p> <ol> <li>Check the Troubleshooting section below</li> <li>Review the Requirements page</li> <li>Visit our GitHub Issues</li> </ol>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/#common-issues","title":"Common Issues","text":"<p>Ruby Version Too Old <pre><code>ruby --version  # Should be 3.2 or higher\nrbenv install 3.3.6  # Or rvm install ruby-3.3.6\n</code></pre></p> <p>TA-Lib Not Found <pre><code># See the Installation guide for TA-Lib setup\n# Quick check:\nls /usr/local/lib/libta_lib.*\n</code></pre></p> <p>API Key Issues <pre><code># Set your Alpha Vantage API key\nexport AV_API_KEY=\"your_key_here\"\n# Or add to ~/.bashrc for persistence\n</code></pre></p> <p>Ready to install? Let's get started with the Installation Guide!</p>"},{"location":"getting-started/installation/","title":"Installation Guide","text":"<p>This guide walks you through installing SQA and all its dependencies.</p>"},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Ruby: 3.2 or higher</li> <li>Operating System: Linux, macOS, or Windows (with WSL)</li> <li>Disk Space: ~100MB for gem and dependencies</li> <li>Internet: Required for downloading stock data</li> </ul>"},{"location":"getting-started/installation/#step-1-install-ta-lib","title":"Step 1: Install TA-Lib","text":"<p>SQA requires the TA-Lib C library for technical analysis calculations.</p>"},{"location":"getting-started/installation/#linux-ubuntudebian","title":"Linux (Ubuntu/Debian)","text":"<pre><code># Download and extract TA-Lib source\ncd /tmp\nwget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz\ntar -xzf ta-lib-0.4.0-src.tar.gz\n\n# Compile and install\ncd ta-lib\n./configure --prefix=/usr/local\nmake\nsudo make install\n\n# Create symlink for compatibility\ncd /usr/local/lib\nsudo ln -s libta_lib.so libta-lib.so\nsudo ldconfig\n\n# Set library path (add to ~/.bashrc for persistence)\nexport LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH\n</code></pre>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<pre><code># Using Homebrew\nbrew install ta-lib\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code># Check that TA-Lib is installed\nls -la /usr/local/lib/libta_lib.*\n\n# Should show files like:\n# libta_lib.a\n# libta_lib.so\n# libta_lib.so.0\n# libta_lib.so.0.0.0\n</code></pre>"},{"location":"getting-started/installation/#step-2-install-sqa-gem","title":"Step 2: Install SQA Gem","text":""},{"location":"getting-started/installation/#from-rubygems-recommended","title":"From RubyGems (Recommended)","text":"<pre><code>gem install sqa\n</code></pre>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<pre><code># Clone the repository\ngit clone https://github.com/madbomber/sqa.git\ncd sqa\n\n# Install dependencies\nbundle install\n\n# Install the gem locally\nrake install\n</code></pre>"},{"location":"getting-started/installation/#step-3-verify-installation","title":"Step 3: Verify Installation","text":"<p>Test that SQA is installed correctly:</p> <pre><code># Launch the SQA console\nsqa-console\n\n# In the console, try:\nSQA::VERSION  # Should display the version number\nSQAI.methods.grep(/^[a-z]/).sort  # List available indicators\n</code></pre> <p>Expected output: <pre><code>=&gt; \"0.0.31\"  # Version number\n\n=&gt; [:acos, :ad, :add, :adosc, :adx, :adxr, ...]  # 150+ indicators\n</code></pre></p>"},{"location":"getting-started/installation/#step-4-configure-api-access-optional","title":"Step 4: Configure API Access (Optional)","text":"<p>To download live stock data, you'll need an Alpha Vantage API key.</p>"},{"location":"getting-started/installation/#get-api-key","title":"Get API Key","text":"<ol> <li>Visit Alpha Vantage</li> <li>Sign up for a free API key</li> <li>Copy your API key</li> </ol>"},{"location":"getting-started/installation/#set-environment-variable","title":"Set Environment Variable","text":"<pre><code># Temporary (current session)\nexport AV_API_KEY=\"your_api_key_here\"\n\n# Permanent (add to ~/.bashrc or ~/.zshrc)\necho 'export AV_API_KEY=\"your_api_key_here\"' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre>"},{"location":"getting-started/installation/#alternative-configuration-file","title":"Alternative: Configuration File","text":"<p>Create <code>~/.sqa.yml</code>:</p> <pre><code>data_dir: ~/sqa_data\ndebug: false\nverbose: false\n</code></pre> <p>The API key is read from environment variables, not the config file.</p>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#ta-lib-not-found","title":"TA-Lib Not Found","text":"<p>Error: <code>cannot load such file -- sqa/tai (LoadError)</code></p> <p>Solution: Make sure TA-Lib is installed and <code>LD_LIBRARY_PATH</code> is set:</p> <pre><code>export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH\n</code></pre>"},{"location":"getting-started/installation/#permission-denied-during-installation","title":"Permission Denied During Installation","text":"<p>Error: <code>Permission denied @ dir_s_mkdir</code></p> <p>Solution: Use <code>sudo</code> for system-wide installation:</p> <pre><code>sudo gem install sqa\n</code></pre> <p>Or install to user directory:</p> <pre><code>gem install --user-install sqa\n</code></pre>"},{"location":"getting-started/installation/#ruby-version-too-old","title":"Ruby Version Too Old","text":"<p>Error: <code>Required Ruby version is &gt;= 3.2.0</code></p> <p>Solution: Update Ruby using rbenv or rvm:</p> <pre><code># Using rbenv\nrbenv install 3.3.6\nrbenv global 3.3.6\n\n# Using rvm\nrvm install 3.3.6\nrvm use 3.3.6 --default\n</code></pre>"},{"location":"getting-started/installation/#bundle-install-fails","title":"Bundle Install Fails","text":"<p>Error: Various dependency errors</p> <p>Solution: Update bundler and try again:</p> <pre><code>gem update --system\ngem install bundler\nbundle install\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have SQA installed:</p> <ol> <li>Quick Start Guide - Run your first analysis</li> <li>Core Concepts - Understand SQA's architecture</li> <li>Trading Strategies - Explore built-in strategies</li> </ol>"},{"location":"getting-started/installation/#additional-dependencies","title":"Additional Dependencies","text":"<p>SQA automatically installs these dependencies:</p> <ul> <li><code>polars-df</code> - High-performance DataFrames</li> <li><code>sqa-tai</code> - TA-Lib wrapper for indicators</li> <li><code>faraday</code> - HTTP client for API calls</li> <li><code>hashie</code> - Enhanced hash objects</li> <li><code>tty-table</code> - Terminal table formatting</li> <li><code>kbs</code> - Knowledge-based strategy framework</li> <li><code>toml-rb</code> - TOML configuration support</li> </ul> <p>For development, you may also want:</p> <ul> <li><code>amazing_print</code> - Pretty printing</li> <li><code>debug_me</code> - Debugging utilities</li> <li><code>minitest</code> - Testing framework</li> <li><code>simplecov</code> - Code coverage</li> </ul>"},{"location":"getting-started/installation/#supported-platforms","title":"Supported Platforms","text":"<p>SQA has been tested on:</p> <ul> <li>\u2705 Ubuntu 20.04+</li> <li>\u2705 Debian 11+</li> <li>\u2705 macOS 12+ (Monterey and later)</li> <li>\u2705 Fedora 35+</li> <li>\u26a0\ufe0f Windows (via WSL recommended)</li> </ul> <p>Having issues? Check our GitHub Issues or create a new one.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start Guide","text":"<p>Get up and running with SQA in just a few minutes!</p>"},{"location":"getting-started/quick-start/#your-first-analysis-5-minutes","title":"Your First Analysis (5 Minutes)","text":""},{"location":"getting-started/quick-start/#1-create-a-simple-script","title":"1. Create a Simple Script","text":"<p>Create a file called <code>my_first_analysis.rb</code>:</p> <pre><code>require 'sqa'\n\n# Initialize SQA\nSQA.init\n\n# Load Apple stock data\nputs \"Loading AAPL data...\"\nstock = SQA::Stock.new(ticker: 'AAPL')\n\n# Display basic information\nputs \"\\n#{stock}\"\nputs \"Data points: #{stock.df.height}\"\nputs \"Date range: #{stock.df['timestamp'].first} to #{stock.df['timestamp'].last}\"\n\n# Get closing prices\nprices = stock.df[\"adj_close_price\"].to_a\nputs \"\\nCurrent price: $#{prices.last}\"\n\n# Calculate RSI (Relative Strength Index)\nrsi_values = SQAI.rsi(prices, period: 14)\ncurrent_rsi = rsi_values.last.round(2)\n\nputs \"Current RSI: #{current_rsi}\"\nputs \"Market condition: #{current_rsi &lt; 30 ? 'Oversold' : current_rsi &gt; 70 ? 'Overbought' : 'Neutral'}\"\n\n# Calculate Simple Moving Average\nsma_20 = SQAI.sma(prices, period: 20)\nsma_50 = SQAI.sma(prices, period: 50)\n\nputs \"\\n20-day SMA: $#{sma_20.last.round(2)}\"\nputs \"50-day SMA: $#{sma_50.last.round(2)}\"\nputs \"Trend: #{sma_20.last &gt; sma_50.last ? 'Bullish' : 'Bearish'}\"\n</code></pre>"},{"location":"getting-started/quick-start/#2-run-the-script","title":"2. Run the Script","text":"<pre><code>ruby my_first_analysis.rb\n</code></pre> <p>Expected output: <pre><code>Loading AAPL data...\n\naapl with 1258 data points from 2019-11-09 to 2024-11-08\nData points: 1258\nDate range: 2019-11-09 to 2024-11-08\n\nCurrent price: $226.96\nCurrent RSI: 48.23\nMarket condition: Neutral\n\n20-day SMA: $225.45\n50-day SMA: $218.32\nTrend: Bullish\n</code></pre></p>"},{"location":"getting-started/quick-start/#backtest-a-strategy-10-minutes","title":"Backtest a Strategy (10 Minutes)","text":"<p>Let's backtest a simple RSI trading strategy:</p> <pre><code>require 'sqa'\n\nSQA.init\n\n# Load stock data\nstock = SQA::Stock.new(ticker: 'AAPL')\n\n# Create and run backtest\nbacktest = SQA::Backtest.new(\n  stock: stock,\n  strategy: SQA::Strategy::RSI,\n  initial_cash: 10_000.0,\n  commission: 1.0  # $1 per trade\n)\n\nputs \"Running backtest for RSI strategy...\"\nresults = backtest.run\n\n# Display results\nputs \"\\n=== Backtest Results ===\"\nputs \"Total Return: #{results.total_return.round(2)}%\"\nputs \"Sharpe Ratio: #{results.sharpe_ratio.round(2)}\"\nputs \"Max Drawdown: #{results.max_drawdown.round(2)}%\"\nputs \"Win Rate: #{results.win_rate.round(2)}%\"\nputs \"\\nTotal Trades: #{results.total_trades}\"\nputs \"Winning Trades: #{results.winning_trades}\"\nputs \"Losing Trades: #{results.losing_trades}\"\nputs \"\\nFinal Portfolio Value: $#{results.final_value.round(2)}\"\n</code></pre>"},{"location":"getting-started/quick-start/#use-multiple-indicators-15-minutes","title":"Use Multiple Indicators (15 Minutes)","text":"<p>Combine several indicators for better analysis:</p> <pre><code>require 'sqa'\n\nSQA.init\n\nstock = SQA::Stock.new(ticker: 'MSFT')\nprices = stock.df[\"adj_close_price\"].to_a\nvolumes = stock.df[\"volume\"].to_a\n\n# Calculate multiple indicators\nputs \"Calculating indicators...\"\n\n# Trend indicators\nsma_20 = SQAI.sma(prices, period: 20)\nema_12 = SQAI.ema(prices, period: 12)\nema_26 = SQAI.ema(prices, period: 26)\n\n# Momentum indicators\nrsi = SQAI.rsi(prices, period: 14)\nmacd_line, signal_line, histogram = SQAI.macd(\n  prices,\n  fast_period: 12,\n  slow_period: 26,\n  signal_period: 9\n)\n\n# Volatility indicators\nupper, middle, lower = SQAI.bbands(prices, period: 20)\n\n# Display current values\nputs \"\\n=== Technical Analysis for MSFT ===\"\nputs \"Price: $#{prices.last.round(2)}\"\nputs \"\\nTrend:\"\nputs \"  SMA(20): $#{sma_20.last.round(2)}\"\nputs \"  EMA(12): $#{ema_12.last.round(2)}\"\nputs \"  EMA(26): $#{ema_26.last.round(2)}\"\n\nputs \"\\nMomentum:\"\nputs \"  RSI: #{rsi.last.round(2)}\"\nputs \"  MACD: #{macd_line.last.round(2)}\"\nputs \"  Signal: #{signal_line.last.round(2)}\"\n\nputs \"\\nVolatility (Bollinger Bands):\"\nputs \"  Upper: $#{upper.last.round(2)}\"\nputs \"  Middle: $#{middle.last.round(2)}\"\nputs \"  Lower: $#{lower.last.round(2)}\"\n\n# Generate trading signal\nsignal = case\n  when rsi.last &lt; 30 &amp;&amp; prices.last &lt; lower.last\n    \"STRONG BUY\"\n  when rsi.last &lt; 40 &amp;&amp; macd_line.last &gt; signal_line.last\n    \"BUY\"\n  when rsi.last &gt; 70 &amp;&amp; prices.last &gt; upper.last\n    \"STRONG SELL\"\n  when rsi.last &gt; 60 &amp;&amp; macd_line.last &lt; signal_line.last\n    \"SELL\"\n  else\n    \"HOLD\"\n  end\n\nputs \"\\nRecommended Action: #{signal}\"\n</code></pre>"},{"location":"getting-started/quick-start/#explore-interactively","title":"Explore Interactively","text":"<p>Use the <code>sqa-console</code> for interactive exploration:</p> <pre><code>sqa-console\n</code></pre> <p>Try these commands in the console:</p> <pre><code># Load a stock\nstock = SQA::Stock.new(ticker: 'GOOGL')\n\n# Explore the dataframe\nstock.df.head(10)\n\n# Get column names\nstock.df.columns\n\n# Calculate any indicator\nprices = stock.df[\"adj_close_price\"].to_a\nSQAI.sma(prices, period: 50)\n\n# List all available indicators\nSQAI.methods.grep(/^[a-z]/).sort\n\n# Try different strategies\nSQA::Strategy.descendants  # List all strategy classes\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you've run your first analyses:</p> <ol> <li>Core Concepts - Understand SQA's architecture</li> <li>Trading Strategies - Explore built-in strategies</li> <li>Advanced Features - Portfolio management, streaming, etc.</li> <li>API Reference - Complete API documentation</li> </ol>"},{"location":"getting-started/quick-start/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quick-start/#load-historical-data","title":"Load Historical Data","text":"<pre><code>stock = SQA::Stock.new(ticker: 'TSLA')\nprices = stock.df[\"adj_close_price\"].to_a\n</code></pre>"},{"location":"getting-started/quick-start/#calculate-indicator","title":"Calculate Indicator","text":"<pre><code>values = SQAI.indicator_name(prices, period: 14)\n</code></pre>"},{"location":"getting-started/quick-start/#apply-strategy","title":"Apply Strategy","text":"<pre><code>require 'ostruct'\nvector = OpenStruct.new(prices: prices, rsi: rsi_values)\nsignal = SQA::Strategy::RSI.trade(vector)\n</code></pre>"},{"location":"getting-started/quick-start/#run-backtest","title":"Run Backtest","text":"<pre><code>backtest = SQA::Backtest.new(stock: stock, strategy: SQA::Strategy::MACD)\nresults = backtest.run\n</code></pre> <p>Tip: Keep the Technical Indicators Reference handy as you explore!</p>"},{"location":"indicators/","title":"Technical Indicators","text":"<p>SQA provides access to 150+ technical indicators via the sqa-tai gem, which wraps the industry-standard TA-Lib library.</p>"},{"location":"indicators/#quick-reference","title":"Quick Reference","text":"<p>All indicators are available through the <code>SQAI</code> module:</p> <pre><code>require 'sqa'\n\nprices = [100, 102, 101, 103, 105, 104, 106]\n\n# Simple Moving Average\nsma = SQAI.sma(prices, period: 5)\n\n# Relative Strength Index\nrsi = SQAI.rsi(prices, period: 14)\n\n# Bollinger Bands (returns 3 arrays: upper, middle, lower)\nupper, middle, lower = SQAI.bbands(prices, period: 20)\n</code></pre>"},{"location":"indicators/#indicator-categories","title":"Indicator Categories","text":""},{"location":"indicators/#overlap-studies-moving-averages","title":"Overlap Studies (Moving Averages)","text":"<ul> <li>SMA - Simple Moving Average</li> <li>EMA - Exponential Moving Average</li> <li>WMA - Weighted Moving Average</li> <li>DEMA - Double Exponential Moving Average</li> <li>TEMA - Triple Exponential Moving Average</li> <li>T3 - Triple Exponential Moving Average (T3)</li> <li>MA - Moving Average (configurable type)</li> </ul>"},{"location":"indicators/#momentum-indicators","title":"Momentum Indicators","text":"<ul> <li>RSI - Relative Strength Index</li> <li>STOCH - Stochastic Oscillator</li> <li>STOCHF - Stochastic Fast</li> <li>STOCHRSI - Stochastic RSI</li> <li>MACD - Moving Average Convergence Divergence</li> <li>MOM - Momentum</li> <li>ROC - Rate of Change</li> <li>CCI - Commodity Channel Index</li> <li>WILLR - Williams' %R</li> </ul>"},{"location":"indicators/#volatility-indicators","title":"Volatility Indicators","text":"<ul> <li>ATR - Average True Range</li> <li>NATR - Normalized Average True Range</li> <li>TRANGE - True Range</li> <li>BBANDS - Bollinger Bands</li> </ul>"},{"location":"indicators/#volume-indicators","title":"Volume Indicators","text":"<ul> <li>AD - Chaikin A/D Line</li> <li>ADOSC - Chaikin A/D Oscillator</li> <li>OBV - On Balance Volume</li> </ul>"},{"location":"indicators/#see-individual-indicators","title":"See Individual Indicators","text":"<p>Browse the navigation menu for detailed information about each indicator.</p>"},{"location":"indicators/#common-patterns","title":"Common Patterns","text":""},{"location":"indicators/#single-value-indicators","title":"Single-Value Indicators","text":"<pre><code># Returns array of values\nvalues = SQAI.rsi(prices, period: 14)\ncurrent_rsi = values.last\n</code></pre>"},{"location":"indicators/#multi-value-indicators","title":"Multi-Value Indicators","text":"<pre><code># MACD returns 3 arrays\nmacd_line, signal_line, histogram = SQAI.macd(prices)\n</code></pre>"},{"location":"indicators/#indicators-requiring-multiple-inputs","title":"Indicators Requiring Multiple Inputs","text":"<pre><code># ATR needs high, low, close\nhigh = [105, 107, 106, 108]\nlow = [103, 104, 103, 105]\nclose = [104, 106, 105, 107]\n\natr = SQAI.atr(high, low, close, period: 14)\n</code></pre>"},{"location":"indicators/#full-indicator-list","title":"Full Indicator List","text":"<p>To see all available indicators:</p> <pre><code>SQAI.methods.grep(/^[a-z]/).sort\n</code></pre> <p>This will list all 150+ indicators in alphabetical order.</p>"},{"location":"strategies/","title":"Trading Strategies","text":"<p>Explore SQA's comprehensive suite of trading strategies.</p>"},{"location":"strategies/#overview","title":"Overview","text":"<p>SQA provides 13+ built-in trading strategies, from simple moving average crossovers to advanced rule-based systems. All strategies follow a common interface and can be easily backtested or combined.</p>"},{"location":"strategies/#strategy-categories","title":"Strategy Categories","text":""},{"location":"strategies/#trend-following-strategies","title":"Trend-Following Strategies","text":"<p>Strategies that identify and follow market trends:</p> <ul> <li>SMA Strategy - Simple Moving Average crossovers</li> <li>EMA Strategy - Exponential Moving Average crossovers</li> <li>MACD Strategy - Moving Average Convergence Divergence</li> </ul>"},{"location":"strategies/#momentum-strategies","title":"Momentum Strategies","text":"<p>Strategies based on price momentum and oscillators:</p> <ul> <li>RSI Strategy - Relative Strength Index (oversold/overbought)</li> <li>Stochastic Strategy - Stochastic oscillator crossovers</li> </ul>"},{"location":"strategies/#volatility-strategies","title":"Volatility Strategies","text":"<p>Strategies that use volatility measures:</p> <ul> <li>Bollinger Bands Strategy - Price touches bands</li> <li>ATR-based Strategies - Average True Range volatility</li> </ul>"},{"location":"strategies/#volume-strategies","title":"Volume Strategies","text":"<p>Strategies incorporating volume analysis:</p> <ul> <li>Volume Breakout - High volume price breakouts</li> </ul>"},{"location":"strategies/#mean-reversion","title":"Mean Reversion","text":"<p>Strategies assuming prices return to average:</p> <ul> <li>Mean Reversion Strategy - Statistical mean reversion</li> </ul>"},{"location":"strategies/#advanced-strategies","title":"Advanced Strategies","text":"<p>Complex, rule-based approaches:</p> <ul> <li>KBS Strategy - Knowledge-Based System with RETE engine</li> <li>Consensus Strategy - Aggregates multiple strategies</li> </ul>"},{"location":"strategies/#using-strategies","title":"Using Strategies","text":""},{"location":"strategies/#basic-usage","title":"Basic Usage","text":"<pre><code>require 'sqa'\nrequire 'ostruct'\n\n# Create data vector\nvector = OpenStruct.new(\n  rsi: { trend: :over_sold },\n  prices: [100, 102, 105, 103, 107]\n)\n\n# Execute strategy\nsignal = SQA::Strategy::RSI.trade(vector)\n# =&gt; :buy, :sell, or :hold\n</code></pre>"},{"location":"strategies/#backtesting","title":"Backtesting","text":"<pre><code>backtest = SQA::Backtest.new(\n  stock: stock,\n  strategy: SQA::Strategy::MACD,\n  initial_cash: 10_000\n)\n\nresults = backtest.run\nputs \"Return: #{results.total_return}%\"\n</code></pre>"},{"location":"strategies/#strategy-comparison","title":"Strategy Comparison","text":"Strategy Complexity Best For Typical Win Rate SMA Low Trending markets 45-55% RSI Low Range-bound markets 50-60% MACD Medium Trending markets 45-55% Bollinger Bands Medium Volatile markets 50-60% KBS High Complex rules Varies"},{"location":"strategies/#next-steps","title":"Next Steps","text":"<ul> <li>Built-in Strategies - Explore each strategy in detail</li> <li>Custom Strategies - Create your own strategies</li> <li>Backtesting - Test strategies historically</li> </ul>"},{"location":"strategies/bollinger-bands/","title":"Bollinger Bands Strategy","text":""},{"location":"strategies/bollinger-bands/#overview","title":"Overview","text":"<p>The Bollinger Bands strategy uses volatility bands to identify oversold and overbought conditions. The strategy generates buy signals when price touches the lower band and sell signals when price touches the upper band.</p>"},{"location":"strategies/bollinger-bands/#how-it-works","title":"How It Works","text":"<p>Bollinger Bands consist of three lines:</p> <ul> <li>Middle Band: 20-period Simple Moving Average (SMA)</li> <li>Upper Band: Middle Band + (2 \u00d7 Standard Deviation)</li> <li>Lower Band: Middle Band - (2 \u00d7 Standard Deviation)</li> </ul> <p>The bands expand and contract based on market volatility. When volatility increases, the bands widen; when volatility decreases, the bands narrow.</p>"},{"location":"strategies/bollinger-bands/#trading-signals","title":"Trading Signals","text":""},{"location":"strategies/bollinger-bands/#buy-signal","title":"Buy Signal","text":"<p>Price touches or falls below the lower band, indicating an oversold condition.</p> <pre><code>current_price &lt;= lower_band  # =&gt; :buy\n</code></pre>"},{"location":"strategies/bollinger-bands/#sell-signal","title":"Sell Signal","text":"<p>Price touches or exceeds the upper band, indicating an overbought condition.</p> <pre><code>current_price &gt;= upper_band  # =&gt; :sell\n</code></pre>"},{"location":"strategies/bollinger-bands/#hold-signal","title":"Hold Signal","text":"<p>Price remains between the bands.</p> <pre><code>lower_band &lt; current_price &lt; upper_band  # =&gt; :hold\n</code></pre>"},{"location":"strategies/bollinger-bands/#parameters","title":"Parameters","text":"Parameter Value Description Period 20 Number of periods for SMA calculation Std Dev 2.0 Number of standard deviations for bands"},{"location":"strategies/bollinger-bands/#usage-example","title":"Usage Example","text":"<pre><code>require 'sqa'\nrequire 'ostruct'\n\n# Load stock data\nstock = SQA::Stock.new(ticker: 'AAPL')\nprices = stock.df[\"adj_close_price\"].to_a\n\n# Create vector with price data\nvector = OpenStruct.new(prices: prices)\n\n# Execute strategy\nsignal = SQA::Strategy::BollingerBands.trade(vector)\nputs \"Signal: #{signal}\"  # =&gt; :buy, :sell, or :hold\n</code></pre>"},{"location":"strategies/bollinger-bands/#backtesting-example","title":"Backtesting Example","text":"<pre><code># Create backtest with Bollinger Bands strategy\nbacktest = SQA::Backtest.new(\n  stock: stock,\n  strategy: SQA::Strategy::BollingerBands,\n  initial_cash: 10_000\n)\n\nresults = backtest.run\n\nputs \"Total Return: #{results.total_return}%\"\nputs \"Sharpe Ratio: #{results.sharpe_ratio}\"\nputs \"Max Drawdown: #{results.max_drawdown}%\"\nputs \"Win Rate: #{results.win_rate}%\"\n</code></pre>"},{"location":"strategies/bollinger-bands/#characteristics","title":"Characteristics","text":"Attribute Value Complexity Medium Best Market Volatile, range-bound markets Typical Win Rate 50-60% Risk Level Medium Time Horizon Short to medium term"},{"location":"strategies/bollinger-bands/#strengths","title":"Strengths","text":"<ul> <li>\u2705 Works well in ranging markets</li> <li>\u2705 Adapts to volatility changes</li> <li>\u2705 Provides clear entry/exit points</li> <li>\u2705 Simple to understand and implement</li> </ul>"},{"location":"strategies/bollinger-bands/#weaknesses","title":"Weaknesses","text":"<ul> <li>\u274c Less effective in strong trends</li> <li>\u274c Can generate false signals during breakouts</li> <li>\u274c Requires sufficient price history (20+ periods)</li> <li>\u274c May whipsaw in choppy markets</li> </ul>"},{"location":"strategies/bollinger-bands/#tips-for-best-results","title":"Tips for Best Results","text":"<ol> <li>Combine with Trend Indicators: Use with RSI or MACD to filter false signals</li> <li>Watch for Band Squeezes: Narrow bands often precede big moves</li> <li>Adjust Parameters: Consider wider bands (3 std dev) for less frequent signals</li> <li>Volume Confirmation: Look for high volume on band touches for stronger signals</li> <li>Avoid in Trends: Strategy works best in sideways markets</li> </ol>"},{"location":"strategies/bollinger-bands/#implementation-details","title":"Implementation Details","text":"<p>The strategy is implemented in <code>lib/sqa/strategy/bollinger_bands.rb</code> and uses TA-Lib's <code>bbands</code> indicator via the <code>sqa-tai</code> gem:</p> <pre><code>class SQA::Strategy::BollingerBands\n  def self.trade(vector)\n    # Calculate Bollinger Bands\n    upper, middle, lower = SQAI.bbands(\n      prices,\n      period: 20,\n      nbdev_up: 2.0,\n      nbdev_down: 2.0\n    )\n\n    # Compare current price to bands\n    # ... (see source for full implementation)\n  end\nend\n</code></pre>"},{"location":"strategies/bollinger-bands/#related-strategies","title":"Related Strategies","text":"<ul> <li>RSI Strategy - Combine for better oversold/overbought detection</li> <li>Volume Breakout - Use together to confirm breakouts</li> <li>Mean Reversion - Similar range-trading approach</li> </ul>"},{"location":"strategies/bollinger-bands/#further-reading","title":"Further Reading","text":"<ul> <li>Bollinger Bands on Wikipedia</li> <li>John Bollinger's Official Site</li> <li>Technical Indicators</li> </ul>"},{"location":"strategies/consensus/","title":"Consensus Strategy","text":""},{"location":"strategies/consensus/#overview","title":"Overview","text":"<p>Aggregates signals from multiple strategies and makes trading decisions based on majority vote. Reduces risk of acting on single false signals.</p>"},{"location":"strategies/consensus/#how-it-works","title":"How It Works","text":"<p>Executes 5 independent strategies and counts votes: - Majority Buy: More buy signals than sell \u2192 Buy - Majority Sell: More sell signals than buy \u2192 Sell - Tie or No Consensus: Hold</p>"},{"location":"strategies/consensus/#trading-signals","title":"Trading Signals","text":"<pre><code>strategies = [Strategy1, Strategy2, Strategy3, Strategy4, Strategy5]\nvotes = strategies.map { |s| s.trade(vector) }\n# votes = [:buy, :buy, :sell, :hold, :buy]\n\n# Count: buy=3, sell=1, hold=1\n# Result: :buy (majority)\n</code></pre>"},{"location":"strategies/consensus/#usage-example","title":"Usage Example","text":"<pre><code>vector = OpenStruct.new(\n  rsi: rsi_data,\n  macd: macd_data,\n  prices: prices\n)\n\nsignal = SQA::Strategy::Consensus.trade(vector)\n# Returns :buy, :sell, or :hold based on majority\n</code></pre>"},{"location":"strategies/consensus/#characteristics","title":"Characteristics","text":"<ul> <li>Complexity: Medium</li> <li>Best Market: All markets</li> <li>Win Rate: 50-60%</li> <li>Reduces: False signals</li> </ul>"},{"location":"strategies/consensus/#strengths","title":"Strengths","text":"<p>\u2705 Reduces false positives \u2705 More reliable than single strategy \u2705 Democratic decision making \u2705 Can combine different approaches  </p>"},{"location":"strategies/consensus/#weaknesses","title":"Weaknesses","text":"<p>\u274c May be slower to act \u274c Can dilute strong signals \u274c Requires multiple data inputs  </p>"},{"location":"strategies/consensus/#tips","title":"Tips","text":"<ol> <li>Diverse Strategies: Mix trend and momentum strategies</li> <li>Odd Number: Use odd number of strategies to avoid ties</li> <li>Weighted Voting: Consider weighting better-performing strategies</li> <li>Threshold: Require super-majority (e.g., 4 out of 5) for higher conviction</li> </ol>"},{"location":"strategies/custom/","title":"Creating Custom Strategies","text":""},{"location":"strategies/custom/#overview","title":"Overview","text":"<p>Learn how to create your own trading strategies in the SQA framework.</p>"},{"location":"strategies/custom/#strategy-interface","title":"Strategy Interface","text":"<p>All strategies must implement a <code>self.trade(vector)</code> class method that returns <code>:buy</code>, <code>:sell</code>, or <code>:hold</code>.</p>"},{"location":"strategies/custom/#basic-template","title":"Basic Template","text":"<pre><code># lib/sqa/strategy/my_strategy.rb\n\nclass SQA::Strategy::MyStrategy\n  def self.trade(vector)\n    # 1. Validate input\n    return :hold unless vector.respond_to?(:prices)\n    return :hold if vector.prices.nil? || vector.prices.size &lt; 20\n\n    # 2. Extract data\n    prices = vector.prices\n\n    # 3. Calculate indicators\n    sma = SQAI.sma(prices, period: 20)\n    rsi = SQAI.rsi(prices, period: 14)\n\n    # 4. Implement trading logic\n    if rsi.last &lt; 30 &amp;&amp; prices.last &gt; sma.last\n      :buy\n    elsif rsi.last &gt; 70 &amp;&amp; prices.last &lt; sma.last\n      :sell\n    else\n      :hold\n    end\n  rescue =&gt; e\n    warn \"MyStrategy error: #{e.message}\"\n    :hold\n  end\nend\n</code></pre>"},{"location":"strategies/custom/#step-by-step-guide","title":"Step-by-Step Guide","text":""},{"location":"strategies/custom/#1-create-strategy-file","title":"1. Create Strategy File","text":"<p>Create a new file in <code>lib/sqa/strategy/</code>:</p> <pre><code>touch lib/sqa/strategy/my_strategy.rb\n</code></pre>"},{"location":"strategies/custom/#2-define-strategy-class","title":"2. Define Strategy Class","text":"<pre><code>class SQA::Strategy::MyStrategy\n  # Your implementation\nend\n</code></pre>"},{"location":"strategies/custom/#3-implement-trade-method","title":"3. Implement Trade Method","text":"<pre><code>def self.trade(vector)\n  # Return :buy, :sell, or :hold\nend\n</code></pre>"},{"location":"strategies/custom/#4-add-error-handling","title":"4. Add Error Handling","text":"<pre><code>def self.trade(vector)\n  # Your logic\nrescue =&gt; e\n  warn \"Error: #{e.message}\"\n  :hold  # Safe default\nend\n</code></pre>"},{"location":"strategies/custom/#5-write-tests","title":"5. Write Tests","text":"<p>Create <code>test/strategy/my_strategy_test.rb</code>:</p> <pre><code>require_relative '../test_helper'\nrequire 'ostruct'\n\nclass MyStrategyTest &lt; Minitest::Test\n  def test_buy_signal\n    prices = [100, 102, 104, 106, 108]\n    vector = OpenStruct.new(prices: prices)\n\n    signal = SQA::Strategy::MyStrategy.trade(vector)\n    assert_equal :buy, signal\n  end\n\n  def test_hold_when_no_data\n    vector = OpenStruct.new\n    signal = SQA::Strategy::MyStrategy.trade(vector)\n    assert_equal :hold, signal\n  end\nend\n</code></pre>"},{"location":"strategies/custom/#advanced-example","title":"Advanced Example","text":"<pre><code>class SQA::Strategy::AdvancedStrategy\n  # Constants for configuration\n  RSI_OVERSOLD = 30\n  RSI_OVERBOUGHT = 70\n  MIN_VOLUME_RATIO = 1.5\n\n  def self.trade(vector)\n    return :hold unless valid_vector?(vector)\n\n    analysis = analyze_market(vector)\n    generate_signal(analysis)\n  end\n\n  private\n\n  def self.valid_vector?(vector)\n    vector.respond_to?(:prices) &amp;&amp;\n    vector.respond_to?(:volumes) &amp;&amp;\n    vector.prices&amp;.size &gt;= 50\n  end\n\n  def self.analyze_market(vector)\n    {\n      rsi: SQAI.rsi(vector.prices, period: 14).last,\n      trend: detect_trend(vector.prices),\n      volume_spike: volume_spike?(vector.volumes)\n    }\n  end\n\n  def self.detect_trend(prices)\n    sma_short = SQAI.sma(prices, period: 20).last\n    sma_long = SQAI.sma(prices, period: 50).last\n\n    sma_short &gt; sma_long ? :up : :down\n  end\n\n  def self.volume_spike?(volumes)\n    current = volumes.last\n    average = volumes.last(20).sum / 20.0\n    current &gt; (average * MIN_VOLUME_RATIO)\n  end\n\n  def self.generate_signal(analysis)\n    if analysis[:rsi] &lt; RSI_OVERSOLD &amp;&amp; \n       analysis[:trend] == :up &amp;&amp; \n       analysis[:volume_spike]\n      :buy\n    elsif analysis[:rsi] &gt; RSI_OVERBOUGHT &amp;&amp; \n          analysis[:trend] == :down &amp;&amp; \n          analysis[:volume_spike]\n      :sell\n    else\n      :hold\n    end\n  end\nend\n</code></pre>"},{"location":"strategies/custom/#best-practices","title":"Best Practices","text":""},{"location":"strategies/custom/#1-validate-input","title":"1. Validate Input","text":"<pre><code>return :hold unless vector.respond_to?(:prices)\nreturn :hold if vector.prices.nil?\nreturn :hold if vector.prices.size &lt; minimum_required\n</code></pre>"},{"location":"strategies/custom/#2-use-available-indicators","title":"2. Use Available Indicators","text":"<pre><code># All TA-Lib indicators available via SQAI\nrsi = SQAI.rsi(prices, period: 14)\nmacd = SQAI.macd(prices)\nbbands = SQAI.bbands(prices, period: 20)\n</code></pre>"},{"location":"strategies/custom/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<pre><code>rescue =&gt; e\n  warn \"#{self.name} error: #{e.message}\"\n  :hold\nend\n</code></pre>"},{"location":"strategies/custom/#4-test-edge-cases","title":"4. Test Edge Cases","text":"<ul> <li>Empty data</li> <li>Insufficient data</li> <li>Nil values</li> <li>Extreme values</li> </ul>"},{"location":"strategies/custom/#5-document-your-logic","title":"5. Document Your Logic","text":"<pre><code># Buy when:\n# 1. RSI indicates oversold (&lt; 30)\n# 2. Price above 20-day SMA (uptrend)\n# 3. Volume confirms (&gt; 1.5x average)\n</code></pre>"},{"location":"strategies/custom/#using-your-strategy","title":"Using Your Strategy","text":""},{"location":"strategies/custom/#with-backtest","title":"With Backtest","text":"<pre><code>backtest = SQA::Backtest.new(\n  stock: stock,\n  strategy: SQA::Strategy::MyStrategy,\n  initial_cash: 10_000\n)\n\nresults = backtest.run\n</code></pre>"},{"location":"strategies/custom/#with-real-time-stream","title":"With Real-Time Stream","text":"<pre><code>stream = SQA::Stream.new(\n  ticker: 'AAPL',\n  strategies: [SQA::Strategy::MyStrategy]\n)\n\nstream.on_signal do |signal, data|\n  puts \"MyStrategy says: #{signal}\"\nend\n</code></pre>"},{"location":"strategies/custom/#with-strategy-generator","title":"With Strategy Generator","text":"<pre><code># Discover patterns and auto-generate strategies\ngenerator = SQA::StrategyGenerator.new(stock: stock)\npatterns = generator.discover_patterns\nstrategy_code = generator.generate_strategy(pattern_index: 0)\n</code></pre>"},{"location":"strategies/custom/#common-patterns","title":"Common Patterns","text":""},{"location":"strategies/custom/#trend-following","title":"Trend Following","text":"<pre><code>if short_ma &gt; long_ma\n  :buy\nelsif short_ma &lt; long_ma\n  :sell\nelse\n  :hold\nend\n</code></pre>"},{"location":"strategies/custom/#mean-reversion","title":"Mean Reversion","text":"<pre><code>deviation = (price - average) / average\nif deviation &lt; -threshold\n  :buy\nelsif deviation &gt; threshold\n  :sell\nelse\n  :hold\nend\n</code></pre>"},{"location":"strategies/custom/#momentum","title":"Momentum","text":"<pre><code>if rsi &lt; oversold_level\n  :buy\nelsif rsi &gt; overbought_level\n  :sell\nelse\n  :hold\nend\n</code></pre>"},{"location":"strategies/custom/#breakout","title":"Breakout","text":"<pre><code>if price &gt; recent_high &amp;&amp; volume &gt; threshold\n  :buy\nelsif price &lt; recent_low &amp;&amp; volume &gt; threshold\n  :sell\nelse\n  :hold\nend\n</code></pre>"},{"location":"strategies/custom/#next-steps","title":"Next Steps","text":"<ol> <li>Study existing strategies in <code>lib/sqa/strategy/</code></li> <li>Read Backtesting Guide</li> <li>Explore Strategy Generator</li> <li>Learn about Risk Management</li> </ol>"},{"location":"strategies/custom/#related","title":"Related","text":"<ul> <li>KBS Strategy - Rule-based strategies</li> <li>Consensus - Combining strategies</li> <li>Backtesting - Testing strategies</li> </ul>"},{"location":"strategies/ema/","title":"EMA (Exponential Moving Average) Strategy","text":""},{"location":"strategies/ema/#overview","title":"Overview","text":"<p>Similar to SMA but gives more weight to recent prices, making it more responsive to price changes.</p>"},{"location":"strategies/ema/#how-it-works","title":"How It Works","text":"<p>Uses EMA crossovers for signals: - Short EMA: 12 or 20-period - Long EMA: 26 or 50-period</p>"},{"location":"strategies/ema/#trading-signals","title":"Trading Signals","text":""},{"location":"strategies/ema/#buy-signal","title":"Buy Signal","text":"<p>Short EMA crosses above long EMA.</p>"},{"location":"strategies/ema/#sell-signal","title":"Sell Signal","text":"<p>Short EMA crosses below long EMA.</p>"},{"location":"strategies/ema/#usage-example","title":"Usage Example","text":"<pre><code>prices = stock.df[\"adj_close_price\"].to_a\n\nema_short = SQAI.ema(prices, period: 12)\nema_long = SQAI.ema(prices, period: 26)\n\nvector = OpenStruct.new(\n  ema_short: ema_short,\n  ema_long: ema_long\n)\n\nsignal = SQA::Strategy::EMA.trade(vector)\n</code></pre>"},{"location":"strategies/ema/#characteristics","title":"Characteristics","text":"<ul> <li>Complexity: Low</li> <li>Best Market: Trending</li> <li>Win Rate: 45-55%</li> </ul>"},{"location":"strategies/ema/#strengths","title":"Strengths","text":"<p>\u2705 Faster than SMA \u2705 Better for short-term trading \u2705 Reduces lag  </p>"},{"location":"strategies/ema/#weaknesses","title":"Weaknesses","text":"<p>\u274c More false signals \u274c Still lags in fast markets  </p>"},{"location":"strategies/kbs/","title":"KBS (Knowledge-Based Strategy)","text":""},{"location":"strategies/kbs/#overview","title":"Overview","text":"<p>Advanced rule-based trading system using RETE forward-chaining inference engine. Combines multiple indicators with custom logic rules.</p>"},{"location":"strategies/kbs/#how-it-works","title":"How It Works","text":"<p>Defines trading rules with conditions and actions: - Conditions (<code>on</code>): Facts that must be true - Actions (<code>perform</code>): What to do when conditions met</p>"},{"location":"strategies/kbs/#rule-definition","title":"Rule Definition","text":"<pre><code>strategy = SQA::Strategy::KBS.new(load_defaults: true)\nkb = strategy.kb\n\n# Add custom rule\nstrategy.add_rule :buy_oversold_uptrend do\n  on :rsi, { level: :oversold }\n  on :trend, { short_term: :up }\n  perform do\n    kb.assert(:signal, { action: :buy, confidence: :high })\n  end\nend\n</code></pre>"},{"location":"strategies/kbs/#default-rules","title":"Default Rules","text":"<p>The KBS strategy includes 10 default rules: 1. Buy on RSI oversold in uptrend 2. Sell on RSI overbought in downtrend 3. Buy on bullish MACD crossover 4. Sell on bearish MACD crossover 5. Buy at lower Bollinger Band 6. Sell at upper Bollinger Band 7. Buy on stochastic oversold crossover 8. Sell on stochastic overbought crossover 9. Buy on SMA golden cross 10. Sell on SMA death cross</p>"},{"location":"strategies/kbs/#usage-example","title":"Usage Example","text":"<pre><code># Use with default rules\nstrategy = SQA::Strategy::KBS.new(load_defaults: true)\n\n# Provide market data\nprices = stock.df[\"adj_close_price\"].to_a\nvector = OpenStruct.new(\n  rsi: SQAI.rsi(prices, period: 14),\n  prices: prices\n)\n\nsignal = strategy.execute(vector)\n</code></pre>"},{"location":"strategies/kbs/#advanced-example","title":"Advanced Example","text":"<pre><code># Create custom strategy without defaults\nstrategy = SQA::Strategy::KBS.new(load_defaults: false)\nkb = strategy.kb\n\n# Define sophisticated multi-condition rule\nstrategy.add_rule :strong_buy do\n  on :rsi, { level: :oversold }\n  on :macd, { crossover: :bullish }\n  on :volume, { level: :high }\n  without :position  # Don't buy if already holding\n\n  perform do\n    kb.assert(:signal, { \n      action: :buy, \n      confidence: :high,\n      reason: :triple_confirmation \n    })\n  end\nend\n\n# Execute\nsignal = strategy.execute(vector)\n</code></pre>"},{"location":"strategies/kbs/#confidence-levels","title":"Confidence Levels","text":"<p>Signals include confidence scoring: - High: 1.0 - Medium: 0.6 - Low: 0.3</p> <p>Multiple rules can fire, with aggregate confidence determining final signal.</p>"},{"location":"strategies/kbs/#characteristics","title":"Characteristics","text":"<ul> <li>Complexity: High</li> <li>Best Market: All markets (depends on rules)</li> <li>Win Rate: Varies (50-70% with good rules)</li> </ul>"},{"location":"strategies/kbs/#strengths","title":"Strengths","text":"<p>\u2705 Highly customizable \u2705 Combines multiple indicators \u2705 Confidence scoring \u2705 Forward-chaining inference \u2705 Can encode expert knowledge  </p>"},{"location":"strategies/kbs/#weaknesses","title":"Weaknesses","text":"<p>\u274c Complex to configure \u274c Requires domain knowledge \u274c Can be slow with many rules \u274c Overfitting risk  </p>"},{"location":"strategies/kbs/#tips","title":"Tips","text":"<ol> <li>Start Simple: Begin with 2-3 rules</li> <li>Test Thoroughly: Backtest each rule independently</li> <li>Avoid Conflicts: Ensure rules don't contradict</li> <li>Use Confidence: Combine weak signals for stronger conviction</li> <li>Monitor Performance: Track which rules fire most often</li> </ol>"},{"location":"strategies/kbs/#available-facts","title":"Available Facts","text":"<p>The KBS strategy processes these fact types: - <code>:rsi</code> - RSI indicator data - <code>:macd</code> - MACD crossovers - <code>:trend</code> - Price trend analysis - <code>:bollinger</code> - Bollinger Band position - <code>:stochastic</code> - Stochastic oscillator - <code>:volume</code> - Volume analysis - <code>:sma_crossover</code> - SMA crossovers</p>"},{"location":"strategies/kbs/#dsl-keywords","title":"DSL Keywords","text":"<ul> <li><code>on</code> - Assert condition (fact must exist with attributes)</li> <li><code>without</code> - Negated condition (fact must NOT exist)</li> <li><code>perform</code> - Action to execute when rule fires</li> </ul>"},{"location":"strategies/kbs/#important-note","title":"Important Note","text":"<p>Due to KBS gem DSL limitations, you must use <code>kb.assert</code> (not just <code>assert</code>) inside <code>perform</code> blocks:</p> <pre><code># CORRECT\nkb = strategy.kb\nstrategy.add_rule :my_rule do\n  on :condition\n  perform { kb.assert(:signal, { action: :buy }) }\nend\n\n# INCORRECT\nstrategy.add_rule :my_rule do\n  on :condition\n  perform { assert(:signal, { action: :buy }) }  # Won't work!\nend\n</code></pre>"},{"location":"strategies/kbs/#related","title":"Related","text":"<ul> <li>Strategy Generator - Auto-generate rules</li> <li>Genetic Programming - Optimize rule parameters</li> </ul>"},{"location":"strategies/macd/","title":"MACD Strategy","text":""},{"location":"strategies/macd/#overview","title":"Overview","text":"<p>Moving Average Convergence Divergence (MACD) is a trend-following momentum indicator that shows the relationship between two moving averages.</p>"},{"location":"strategies/macd/#how-it-works","title":"How It Works","text":"<p>MACD consists of three components: - MACD Line: 12-period EMA - 26-period EMA - Signal Line: 9-period EMA of MACD Line - Histogram: MACD Line - Signal Line</p>"},{"location":"strategies/macd/#trading-signals","title":"Trading Signals","text":""},{"location":"strategies/macd/#buy-signal-bullish-crossover","title":"Buy Signal (Bullish Crossover)","text":"<p>MACD line crosses above the signal line.</p> <pre><code>SQA::Strategy::MACD.trade(vector)  # =&gt; :buy\n</code></pre>"},{"location":"strategies/macd/#sell-signal-bearish-crossover","title":"Sell Signal (Bearish Crossover)","text":"<p>MACD line crosses below the signal line.</p> <pre><code>SQA::Strategy::MACD.trade(vector)  # =&gt; :sell\n</code></pre>"},{"location":"strategies/macd/#usage-example","title":"Usage Example","text":"<pre><code>stock = SQA::Stock.new(ticker: 'AAPL')\nprices = stock.df[\"adj_close_price\"].to_a\n\n# Calculate MACD\nmacd_line, signal_line, histogram = SQAI.macd(\n  prices,\n  fast_period: 12,\n  slow_period: 26,\n  signal_period: 9\n)\n\nvector = OpenStruct.new(\n  macd: [macd_line, signal_line, histogram]\n)\n\nsignal = SQA::Strategy::MACD.trade(vector)\n</code></pre>"},{"location":"strategies/macd/#parameters","title":"Parameters","text":"Parameter Default Description Fast Period 12 Fast EMA period Slow Period 26 Slow EMA period Signal Period 9 Signal line EMA period"},{"location":"strategies/macd/#characteristics","title":"Characteristics","text":"Attribute Value Complexity Medium Best Market Trending Win Rate 45-55% Time Horizon Medium to long term"},{"location":"strategies/macd/#strengths","title":"Strengths","text":"<ul> <li>\u2705 Excellent trend following</li> <li>\u2705 Combines trend and momentum</li> <li>\u2705 Clear crossover signals</li> <li>\u2705 Can detect trend changes early</li> </ul>"},{"location":"strategies/macd/#weaknesses","title":"Weaknesses","text":"<ul> <li>\u274c Lags in fast markets</li> <li>\u274c Whipsaws in ranging markets</li> <li>\u274c False signals during consolidation</li> </ul>"},{"location":"strategies/macd/#tips","title":"Tips","text":"<ol> <li>Confirm with Trend: Best in established trends</li> <li>Histogram Divergence: Watch for divergence with price</li> <li>Zero Line Cross: Additional confirmation signal</li> <li>Multiple Timeframes: Align daily and weekly signals</li> </ol>"},{"location":"strategies/macd/#related-strategies","title":"Related Strategies","text":"<ul> <li>EMA - Uses moving average crossovers</li> <li>SMA - Similar crossover approach</li> <li>RSI - Complementary momentum indicator</li> </ul>"},{"location":"strategies/macd/#further-reading","title":"Further Reading","text":"<ul> <li>MACD on Investopedia</li> </ul>"},{"location":"strategies/market-profile/","title":"Market Profile Strategy","text":""},{"location":"strategies/market-profile/#overview","title":"Overview","text":"<p>Uses market profile analysis to identify support and resistance levels, generating signals when price reaches these key levels.</p>"},{"location":"strategies/market-profile/#how-it-works","title":"How It Works","text":"<p>Analyzes price distribution to find: - Value Area: Where most trading occurred - Support: Lower boundary (buy zone) - Resistance: Upper boundary (sell zone)</p>"},{"location":"strategies/market-profile/#trading-signals","title":"Trading Signals","text":""},{"location":"strategies/market-profile/#buy-signal","title":"Buy Signal","text":"<p>Price at support level (<code>:support</code>).</p>"},{"location":"strategies/market-profile/#sell-signal","title":"Sell Signal","text":"<p>Price at resistance level (<code>:resistance</code>).</p>"},{"location":"strategies/market-profile/#hold-signal","title":"Hold Signal","text":"<p>Price within value area (<code>:mixed</code>).</p>"},{"location":"strategies/market-profile/#usage-example","title":"Usage Example","text":"<pre><code># Market profile data typically comes from\n# price/volume distribution analysis\nvector = OpenStruct.new(\n  market_profile: :support  # or :resistance, :mixed\n)\n\nsignal = SQA::Strategy::MP.trade(vector)\n</code></pre>"},{"location":"strategies/market-profile/#characteristics","title":"Characteristics","text":"<ul> <li>Complexity: High</li> <li>Best Market: Range-bound</li> <li>Win Rate: 55-65%</li> </ul>"},{"location":"strategies/market-profile/#strengths","title":"Strengths","text":"<p>\u2705 Identifies key price levels \u2705 Works well for intraday trading \u2705 Statistical basis  </p>"},{"location":"strategies/market-profile/#weaknesses","title":"Weaknesses","text":"<p>\u274c Requires volume profile data \u274c Complex to calculate \u274c Less effective in trending markets  </p>"},{"location":"strategies/mean-reversion/","title":"Mean Reversion Strategy","text":""},{"location":"strategies/mean-reversion/#overview","title":"Overview","text":"<p>Based on the theory that prices tend to return to their average over time. Buys when price is below average and sells when above.</p>"},{"location":"strategies/mean-reversion/#how-it-works","title":"How It Works","text":"<p>Calculates distance from moving average: - Below average: Expect price to rise (buy) - Above average: Expect price to fall (sell)</p>"},{"location":"strategies/mean-reversion/#trading-signals","title":"Trading Signals","text":""},{"location":"strategies/mean-reversion/#buy-signal","title":"Buy Signal","text":"<p>Price significantly below SMA (undervalued).</p>"},{"location":"strategies/mean-reversion/#sell-signal","title":"Sell Signal","text":"<p>Price significantly above SMA (overvalued).</p>"},{"location":"strategies/mean-reversion/#usage-example","title":"Usage Example","text":"<pre><code>prices = stock.df[\"adj_close_price\"].to_a\nsma = SQAI.sma(prices, period: 20)\n\ncurrent_price = prices.last\ncurrent_sma = sma.last\ndeviation = ((current_price - current_sma) / current_sma) * 100\n\n# Buy if more than 5% below SMA\nsignal = if deviation &lt; -5.0\n  :buy\nelsif deviation &gt; 5.0\n  :sell\nelse\n  :hold\nend\n</code></pre>"},{"location":"strategies/mean-reversion/#characteristics","title":"Characteristics","text":"<ul> <li>Complexity: Low</li> <li>Best Market: Range-bound, low volatility</li> <li>Win Rate: 55-65%</li> </ul>"},{"location":"strategies/mean-reversion/#strengths","title":"Strengths","text":"<p>\u2705 High win rate in ranging markets \u2705 Clear mathematical basis \u2705 Works well with statistical analysis  </p>"},{"location":"strategies/mean-reversion/#weaknesses","title":"Weaknesses","text":"<p>\u274c Fails in trending markets \u274c Can lead to \"catching falling knives\" \u274c Requires stable market conditions  </p>"},{"location":"strategies/rsi/","title":"RSI Strategy","text":""},{"location":"strategies/rsi/#overview","title":"Overview","text":"<p>The Relative Strength Index (RSI) strategy identifies overbought and oversold conditions using momentum oscillators. It generates signals when RSI crosses key thresholds.</p>"},{"location":"strategies/rsi/#how-it-works","title":"How It Works","text":"<p>RSI is a momentum oscillator that ranges from 0 to 100: - Over 70: Overbought (sell signal) - Under 30: Oversold (buy signal) - 30-70: Neutral (hold)</p>"},{"location":"strategies/rsi/#trading-signals","title":"Trading Signals","text":""},{"location":"strategies/rsi/#buy-signal-rsilevel-oversold","title":"Buy Signal (<code>rsi.level == :oversold</code>)","text":"<pre><code>SQA::Strategy::RSI.trade(vector)  # =&gt; :buy when RSI &lt; 30\n</code></pre>"},{"location":"strategies/rsi/#sell-signal-rsilevel-overbought","title":"Sell Signal (<code>rsi.level == :overbought</code>)","text":"<pre><code>SQA::Strategy::RSI.trade(vector)  # =&gt; :sell when RSI &gt; 70\n</code></pre>"},{"location":"strategies/rsi/#usage-example","title":"Usage Example","text":"<pre><code>require 'sqa'\nrequire 'ostruct'\n\nstock = SQA::Stock.new(ticker: 'AAPL')\nprices = stock.df[\"adj_close_price\"].to_a\n\n# Calculate RSI using TA-Lib\nrsi_values = SQAI.rsi(prices, period: 14)\n\n# Create indicator data structure\nrsi_data = {\n  value: rsi_values.last,\n  trend: rsi_values.last &lt; 30 ? :over_sold : \n         rsi_values.last &gt; 70 ? :over_bought : :neutral\n}\n\nvector = OpenStruct.new(rsi: rsi_data)\nsignal = SQA::Strategy::RSI.trade(vector)\n</code></pre>"},{"location":"strategies/rsi/#parameters","title":"Parameters","text":"Parameter Default Description Period 14 Number of periods for RSI calculation Oversold 30 Lower threshold for buy signals Overbought 70 Upper threshold for sell signals"},{"location":"strategies/rsi/#characteristics","title":"Characteristics","text":"Attribute Value Complexity Low Best Market Range-bound, volatile Win Rate 50-60% Time Horizon Short to medium term"},{"location":"strategies/rsi/#strengths","title":"Strengths","text":"<ul> <li>\u2705 Simple and well-understood</li> <li>\u2705 Works in ranging markets</li> <li>\u2705 Can identify divergences</li> <li>\u2705 Fast response to price changes</li> </ul>"},{"location":"strategies/rsi/#weaknesses","title":"Weaknesses","text":"<ul> <li>\u274c Fails in strong trends</li> <li>\u274c Can stay overbought/oversold for extended periods</li> <li>\u274c Generates false signals</li> </ul>"},{"location":"strategies/rsi/#tips","title":"Tips","text":"<ol> <li>Combine with Trend: Only take buy signals in uptrends</li> <li>Adjust Thresholds: Use 20/80 for more conservative signals</li> <li>Watch Divergences: Price makes new highs but RSI doesn't (bearish divergence)</li> <li>Volume Confirmation: Stronger signals with high volume</li> </ol>"},{"location":"strategies/rsi/#related-strategies","title":"Related Strategies","text":"<ul> <li>Stochastic - Similar momentum oscillator</li> <li>MACD - Trend-following momentum</li> <li>Bollinger Bands - Volatility-based signals</li> </ul>"},{"location":"strategies/rsi/#further-reading","title":"Further Reading","text":"<ul> <li>RSI on Investopedia</li> <li>Technical Indicators</li> </ul>"},{"location":"strategies/sma/","title":"SMA (Simple Moving Average) Strategy","text":""},{"location":"strategies/sma/#overview","title":"Overview","text":"<p>The SMA strategy uses crossovers of short-term and long-term simple moving averages to identify trend changes and generate trading signals.</p>"},{"location":"strategies/sma/#how-it-works","title":"How It Works","text":"<p>Compares two SMAs: - Short SMA: Faster, more responsive (e.g., 50-day) - Long SMA: Slower, smoother (e.g., 200-day)</p>"},{"location":"strategies/sma/#trading-signals","title":"Trading Signals","text":""},{"location":"strategies/sma/#buy-signal-golden-cross","title":"Buy Signal (Golden Cross)","text":"<p>Short SMA crosses above long SMA.</p>"},{"location":"strategies/sma/#sell-signal-death-cross","title":"Sell Signal (Death Cross)","text":"<p>Short SMA crosses below long SMA.</p>"},{"location":"strategies/sma/#usage-example","title":"Usage Example","text":"<pre><code>stock = SQA::Stock.new(ticker: 'AAPL')\nprices = stock.df[\"adj_close_price\"].to_a\n\nsma_short = SQAI.sma(prices, period: 50)\nsma_long = SQAI.sma(prices, period: 200)\n\nvector = OpenStruct.new(\n  sma_short: sma_short,\n  sma_long: sma_long\n)\n\nsignal = SQA::Strategy::SMA.trade(vector)\n</code></pre>"},{"location":"strategies/sma/#characteristics","title":"Characteristics","text":"<ul> <li>Complexity: Low</li> <li>Best Market: Trending</li> <li>Win Rate: 45-55%</li> </ul>"},{"location":"strategies/sma/#strengths","title":"Strengths","text":"<p>\u2705 Simple and reliable \u2705 Filters market noise \u2705 Identifies major trends  </p>"},{"location":"strategies/sma/#weaknesses","title":"Weaknesses","text":"<p>\u274c Significant lag \u274c Late entry/exit \u274c Poor in ranging markets  </p>"},{"location":"strategies/stochastic/","title":"Stochastic Oscillator Strategy","text":""},{"location":"strategies/stochastic/#overview","title":"Overview","text":"<p>Compares closing price to the price range over a period to identify overbought/oversold conditions and momentum changes.</p>"},{"location":"strategies/stochastic/#how-it-works","title":"How It Works","text":"<p>Calculates two lines: - %K Line: (Current Close - Lowest Low) / (Highest High - Lowest Low) \u00d7 100 - %D Line: 3-period SMA of %K</p> <p>Range: 0-100</p>"},{"location":"strategies/stochastic/#trading-signals","title":"Trading Signals","text":""},{"location":"strategies/stochastic/#buy-signal","title":"Buy Signal","text":"<ul> <li>%K crosses above %D</li> <li>Both below 20 (oversold zone)</li> </ul>"},{"location":"strategies/stochastic/#sell-signal","title":"Sell Signal","text":"<ul> <li>%K crosses below %D</li> <li>Both above 80 (overbought zone)</li> </ul>"},{"location":"strategies/stochastic/#usage-example","title":"Usage Example","text":"<pre><code>high = stock.df[\"high_price\"].to_a\nlow = stock.df[\"low_price\"].to_a\nclose = stock.df[\"adj_close_price\"].to_a\n\nstoch_k, stoch_d = SQAI.stoch(\n  high, low, close,\n  fastk_period: 14,\n  slowk_period: 3,\n  slowd_period: 3\n)\n\nvector = OpenStruct.new(\n  stoch_k: stoch_k,\n  stoch_d: stoch_d\n)\n\nsignal = SQA::Strategy::Stochastic.trade(vector)\n</code></pre>"},{"location":"strategies/stochastic/#characteristics","title":"Characteristics","text":"<ul> <li>Complexity: Medium</li> <li>Best Market: Range-bound</li> <li>Win Rate: 50-60%</li> </ul>"},{"location":"strategies/stochastic/#strengths","title":"Strengths","text":"<p>\u2705 Good for reversals \u2705 Works in ranging markets \u2705 Early signals  </p>"},{"location":"strategies/stochastic/#weaknesses","title":"Weaknesses","text":"<p>\u274c Many false signals in trends \u274c Can stay overbought/oversold  </p>"},{"location":"strategies/volume-breakout/","title":"Volume Breakout Strategy","text":""},{"location":"strategies/volume-breakout/#overview","title":"Overview","text":"<p>Identifies price breakouts confirmed by high trading volume for stronger signal reliability.</p>"},{"location":"strategies/volume-breakout/#how-it-works","title":"How It Works","text":"<p>Looks for: 1. Price breaking above recent high or below recent low 2. Volume exceeding 1.5x the average volume</p>"},{"location":"strategies/volume-breakout/#trading-signals","title":"Trading Signals","text":""},{"location":"strategies/volume-breakout/#buy-signal","title":"Buy Signal","text":"<ul> <li>Price breaks above 20-period high</li> <li>Volume &gt; 1.5\u00d7 average volume</li> </ul>"},{"location":"strategies/volume-breakout/#sell-signal","title":"Sell Signal","text":"<ul> <li>Price breaks below 20-period low</li> <li>Volume &gt; 1.5\u00d7 average volume</li> </ul>"},{"location":"strategies/volume-breakout/#usage-example","title":"Usage Example","text":"<pre><code>prices = stock.df[\"adj_close_price\"].to_a\nvolumes = stock.df[\"volume\"].to_a\n\nvector = OpenStruct.new(\n  prices: prices,\n  volumes: volumes\n)\n\nsignal = SQA::Strategy::VolumeBreakout.trade(vector)\n</code></pre>"},{"location":"strategies/volume-breakout/#characteristics","title":"Characteristics","text":"<ul> <li>Complexity: Medium</li> <li>Best Market: Breakout/trending</li> <li>Win Rate: 50-60%</li> </ul>"},{"location":"strategies/volume-breakout/#strengths","title":"Strengths","text":"<p>\u2705 Volume confirmation reduces false breakouts \u2705 Catches strong moves \u2705 Clear entry points  </p>"},{"location":"strategies/volume-breakout/#weaknesses","title":"Weaknesses","text":"<p>\u274c Rare signals \u274c Can whipsaw on false breakouts \u274c Requires both price and volume data  </p>"}]}